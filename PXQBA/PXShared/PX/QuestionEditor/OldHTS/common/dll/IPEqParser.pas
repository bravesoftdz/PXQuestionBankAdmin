unit IPEqParser;




{==============================================================================
IPEqParser
0.0.0.163
Date of Generation: 10/27/2008 10:07 AM
Comment: 
Author: 
Copyright: 

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses
  SysUtils,Classes,CocoBase,IPEqNode,Contnrs,IPEqDivide,IPEqSqrt,IPEqText,
  IPEqChar,IPEqSuperscript,IPEqSymbolW,IPEqOp,IPEqSupSub,IPEqOverUnder,IPEqLDiv,
  IPEqABS,IPEqCIS,IPEqBar,IPEqMat,IPEqIntegral,IPEqSum,IPEqCBrace,IPEqParen,
  IPEqObject,IPEqPrime,IPEqCheck,IPEqBigger,IPEqVariable,IPStrUtils,StrUtils,
  IPEqItalic,IPEqMNum,IPEqPlainText,Graphics,mwStringHashList;



const
maxT = 109;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EIPEqParser = class(Exception);
  TIPEqParser = class;

  TIPEqParserScanner = class(TCocoRScanner)
  private
    FOwner : TIPEqParser;
fHashList: TmwStringHashList;
function CharInIgnoreSet(const Ch : char) : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TIPEqParser read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TIPEqParserScanner }

  TIPEqParser = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..1] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : string;
    function GetVersionStr : string;
    procedure SetVersion(const Value : string);
    function GetVersionInfo : string;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _EqCheckCol (eqCheck:TIPEqCheck);
    procedure _EqMatRow (eqMat:TIPEqMat);
    procedure _EqDollarChar (eqRow:TIPEqRow);
    procedure _EqPlainText (eqRow:TIPEqRow);
    procedure _EqBold (eqRow:TIPEqRow);
    procedure _EqItalic (eqRow:TIPEqRow);
    procedure _EqBigger (eqRow:TIPEqRow);
    procedure _EqCheck (eqRow:TIPEqRow);
    procedure _EqInput (eqRow:TIPEqRow);
    procedure _EqHBraceB (eqRow:TIPEqRow);
    procedure _EqHBraceT (eqRow:TIPEqRow);
    procedure _EqHBrace (eqRow:TIPEqRow);
    procedure _EqDBraceR (eqRow:TIPEqRow);
    procedure _EqDBraceL (eqRow:TIPEqRow);
    procedure _EqGrint (eqRow:TIPEqRow);
    procedure _EqVectorR (eqRow:TIPEqRow);
    procedure _EqVectorL (eqRow:TIPEqRow);
    procedure _EqVector (eqRow:TIPEqRow);
    procedure _EqBraceR (eqRow:TIPEqRow);
    procedure _EqBraceL (eqRow:TIPEqRow);
    procedure _EqBrace (eqRow:TIPEqRow);
    procedure _EqParenR (eqRow:TIPEqRow);
    procedure _EqParenL (eqRow:TIPEqRow);
    procedure _EqParen (eqRow:TIPEqRow);
    procedure _EqCBraceR (eqRow:TIPEqRow);
    procedure _EqCBraceL (eqRow:TIPEqRow);
    procedure _EqCBrace (eqRow:TIPEqRow);
    procedure _EqSum (eqRow:TIPEqRow);
    procedure _EqIntegral (eqRow:TIPEqRow);
    procedure _EqTableR (eqRow:TIPEqRow);
    procedure _EqTableL (eqRow:TIPEqRow);
    procedure _EqTable (eqRow:TIPEqRow);
    procedure _EqTabR (eqRow:TIPEqRow);
    procedure _EqTabL (eqRow:TIPEqRow);
    procedure _EqTab (eqRow:TIPEqRow);
    procedure _EqColumnR (eqRow:TIPEqRow);
    procedure _EqColumnL (eqRow:TIPEqRow);
    procedure _EqColumn (eqRow:TIPEqRow);
    procedure _EqRowR (eqRow:TIPEqRow);
    procedure _EqRowL (eqRow:TIPEqRow);
    procedure _EqRowC (eqRow:TIPEqRow);
    procedure _EqAugmentR (eqRow:TIPEqRow);
    procedure _EqAugmentL (eqRow:TIPEqRow);
    procedure _EqAugment (eqRow:TIPEqRow);
    procedure _EqMatR (eqRow:TIPEqRow);
    procedure _EqMatL (eqRow:TIPEqRow);
    procedure _EqMat (eqRow:TIPEqRow);
    procedure _EqRep (eqRow:TIPEqRow);
    procedure _EqPrime3 (eqRow:TIPEqRow);
    procedure _EqPrime2 (eqRow:TIPEqRow);
    procedure _EqPrime (eqRow:TIPEqRow);
    procedure _EqUmlaut (eqRow:TIPEqRow);
    procedure _EqAccent (eqRow:TIPEqRow);
    procedure _EqTilde (eqRow:TIPEqRow);
    procedure _EqHat (eqRow:TIPEqRow);
    procedure _EqSlash (eqRow:TIPEqRow);
    procedure _EqARC (eqRow:TIPEqRow);
    procedure _EqUndrBRC (eqRow:TIPEqRow);
    procedure _EqOverBRC (eqRow:TIPEqRow);
    procedure _EqRayDB (eqRow:TIPEqRow);
    procedure _EqRayR (eqRow:TIPEqRow);
    procedure _EqRayL (eqRow:TIPEqRow);
    procedure _EqArrowDB (eqRow:TIPEqRow);
    procedure _EqArrowR (eqRow:TIPEqRow);
    procedure _EqArrowL (eqRow:TIPEqRow);
    procedure _EqUndbbar (eqRow:TIPEqRow);
    procedure _EqOvdbbar (eqRow:TIPEqRow);
    procedure _EqUndrbar (eqRow:TIPEqRow);
    procedure _EqOverbar (eqRow:TIPEqRow);
    procedure _EqSyndiv (eqRow:TIPEqRow);
    procedure _EqCIS (eqRow:TIPEqRow);
    procedure _EqNORMR (eqRow:TIPEqRow);
    procedure _EqNORML (eqRow:TIPEqRow);
    procedure _EqNORM (eqRow:TIPEqRow);
    procedure _EqABSR (eqRow:TIPEqRow);
    procedure _EqABSL (eqRow:TIPEqRow);
    procedure _EqABS (eqRow:TIPEqRow);
    procedure _EqLDivQ (eqRow:TIPEqRow);
    procedure _EqLDiv (eqRow:TIPEqRow);
    procedure _EqUnder (eqRow:TIPEqRow);
    procedure _EqOver (eqRow:TIPEqRow);
    procedure _EqOverUnder (eqRow:TIPEqRow);
    procedure _EqSupSub (eqRow:TIPEqRow);
    procedure _EqMixedNum (eqRow:TIPEqRow);
    procedure _EqParenChar (eqRow:TIPEqRow);
    procedure _EqOperator (eqRow:TIPEqRow);
    procedure _EqNum4 (eqRow:TIPEqRow);
    procedure _EqNum3 (eqRow:TIPEqRow);
    procedure _EqNum2 (eqRow:TIPEqRow);
    procedure _EqNum1 (eqRow:TIPEqRow);
    procedure _EqNum (eqRow:TIPEqRow);
    procedure _EqEntity (eqRow:TIPEqRow);
    procedure _EqSub (eqRow:TIPEqRow);
    procedure _EqSuper (eqRow:TIPEqRow);
    procedure _EqSqrt (eqRow:TIPEqRow);
    procedure _EqDivSM (eqRow:TIPEqRow);
    procedure _EqDiv (eqRow:TIPEqRow);
    procedure _EqText (eqRow:TIPEqRow);
    procedure _EqNode (eqRow:TIPEqRow);
    procedure _EqRow (eqRow:TIPEqRow);
    procedure _EqVar (eqRow:TIPEqRow);
    procedure _IPEqParser;
    procedure _Expect(n : integer);


  private
    FEqDocument : TIPEqDocument;
    FNodeList : TObjectList;
//    FOnSymVarCreate : TTDXSymVarCreateEvent;
//    FOnSymVarGetValue: TTDXSymVarGetValueEvent;
                                     
    procedure Init;
    procedure Final;
    function AddNode(ANode:TIPEqNode):TIPEqNode;
    function PopNode(ANode:TIPEqNode):TIPEqNode;  
    function deQuote(const str:String):String;   
    function GetNumArg(text:String):String;
    function GetCNumArg(text:String):String;
    
  
  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : string) : string; override;
    procedure Execute;
    function GetScanner : TIPEqParserScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : string read GetVersionStr;
    property VersionInfo : string read GetVersionInfo;

  public
    property EqDocument: TIPEqDocument read FEqDocument write FEqDocument;
//    property OnSymVarCreate:TTDXSymVarCreateEvent read FOnSymVarCreate write FOnSymVarCreate;
//    property OnSymVarGetValue:TTDXSymVarGetValueEvent read FOnSymVarGetValue write FOnSymVarGetValue;
  
  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : string read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TIPEqParser }

implementation



const

  EOFSYMB = 0;  text_Sym = 1;  enttext_Sym = 2;  literal_Sym = 3;
  operator_Sym = 4;  minus_Sym = 5;  dollar_Sym = 6;  paren_Sym = 7;
  rparen_Sym = 8;  lparen_Sym = 9;  _lbraceSym = 10;  _rbraceSym = 11;
  _atINPUTSym = 12;  _atDIVSym = 13;  _semicolonSym = 14;  _atDIVSMSym = 15;
  _atSUPSUBSym = 16;  _atOVERUNDERSym = 17;  _atOVERUNDRSym = 18;
  _atOVERSym = 19;  _atUNDERSym = 20;  _atLDIVSym = 21;  _atLDIVQSym = 22;
  _atCBRACESym = 23;  _atCBRACELSym = 24;  _atCBRACERSym = 25;
  _atPARENSym = 26;  _atPARENLSym = 27;  _atPARENRSym = 28;  _atBRACESym = 29;
  _atBRACELSym = 30;  _atBRACERSym = 31;  _atVECTORSym = 32;
  _atVECTORLSym = 33;  _atVECTORRSym = 34;  _atGRINTSym = 35;
  _atDBRACELSym = 36;  _atDBRACERSym = 37;  _atHBRACESym = 38;
  _atHBRACETSym = 39;  _atHBRACEBSym = 40;  _atABSSym = 41;  _atABSLSym = 42;
  _atABSRSym = 43;  _atNORMSym = 44;  _atNORMLSym = 45;  _atNORMRSym = 46;
  _atCISSym = 47;  _atSIZESym = 48;  _atSYNDIVSym = 49;  _atOVERBARSym = 50;
  _atUNDRBARSym = 51;  _atOVDBBARSym = 52;  _atUNDBBARSym = 53;
  _atARROWLSym = 54;  _atARROWRSym = 55;  _atARROWDBSym = 56;  _atRAYLSym = 57;
  _atRAYRSym = 58;  _atRAYDBSym = 59;  _atOVERBRCSym = 60;  _atUNDRBRCSym = 61;
  _atARCSym = 62;  _atSLASHSym = 63;  _atHATSym = 64;  _atTILDESym = 65;
  _atACCENTSym = 66;  _atUMLAUTSym = 67;  _atPRIMESym = 68;
  _atPRIME_twoSym = 69;  _atPRIME_threeSym = 70;  _atREPSym = 71;
  _atMNUMSym = 72;  _atMIXSym = 73;  _atNUMSym = 74;  NUM_lparenSym = 75;
  _atCNUMSym = 76;  _atCURRSym = 77;  _atNEGPSym = 78;  _atRTSym = 79;
  _atSUPSym = 80;  _uparrowSym = 81;  _atSUBSym = 82;  _underscoreSym = 83;
  _atMATSym = 84;  _atCHECKSym = 85;  _atMATLSym = 86;  _atMATRSym = 87;
  _atAUGMENTSym = 88;  _atAUGMENTLSym = 89;  _atAUGMENTRSym = 90;
  _atROWSym = 91;  _atROWLSym = 92;  _atROWRSym = 93;  _atCOLUMNSym = 94;
  _atCOLUMNLSym = 95;  _atCOLUMNRSym = 96;  _atTABSym = 97;  _atTABLSym = 98;
  _atTABRSym = 99;  _atTABLESym = 100;  _atTABLELSym = 101;  _atTABLERSym = 102;
  _atINTEGRALSym = 103;  _atSUMSym = 104;  _atISym = 105;  _atBSym = 106;
  _atTSym = 107; _atVARSym = 108;
  NOSYMB = 109;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
procedure TIPEqParser.Init;
begin
//  FTopRow := TIPEqRow.Create;
end;

procedure TIPEqParser.Final;
begin                   
  //Clean up in between parses just in case object stays around.
  FNodeList.Clear;
end;

function TIPEqParser.AddNode(ANode:TIPEqNode):TIPEqNode;
begin
  FNodeList.Add(ANode);
  Result := ANode;
end;

function TIPEqParser.PopNode(ANode:TIPEqNode):TIPEqNode;
begin
  FNodeList.Extract(ANode);
  Result := ANode;
end;  

function TIPEqParser.deQuote(const str:String):String;
var
  p : PChar;
begin                          
  p := Pchar(str);
  Result := AnsiExtractQuotedStr(p,str[1]);
end;

function TIPEqParser.GetNumArg(text:String):String;
begin
  text := Trim(text);
  Result := deQuote(text);
end;

function TIPEqParser.GetCNumArg(text:String):String;
var
  pPos : integer;
  fStr : String;          
  v : Double;
begin
  text := Trim(text);
  try
    v := StrToFloat(text);
  except
    raise Exception.Create('Argument of CNUM must be a number');
  end;
  
  pPos := Pos('.',text);
  if pPos > 0 then
    fStr := '#,###.'+DupeString('#',Length(text)-pPos)
  else
    fStr := '#,###';
  Result := IPFormatFloat(v,fstr);
end;


(* End of Arbitrary Code *)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TIPEqParserScanner ---- }

procedure TIPEqParserScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}


function TIPEqParserScanner.CharInIgnoreSet(const Ch : char) : boolean;
begin
Result := ((CurrInputCh >= CHR(1)) AND (CurrInputCh <= CHR(31)));
end; {CharInIgnoreSet}


procedure TIPEqParserScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while CharInIgnoreSet(CurrInputCh) do
  NextCh;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '#') OR
(CurrInputCh = '%') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh = '?') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= '`') AND (CurrInputCh <= 'z') OR
(CurrInputCh = '|') OR
(CurrInputCh >= '~') AND (CurrInputCh <= CHR(127)) OR
(CurrInputCh >= CHR(129)) AND (CurrInputCh <= CHR(162)) OR
(CurrInputCh = CHR(164)) OR
(CurrInputCh >= CHR(166))) then
begin
 
end
else
begin
sym := text_Sym;
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z')) then
begin
state := 3; 
end
else
begin
  sym := _noSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z')) then
begin
 
end
else if (CurrInputCh = ';') then
begin
state := 4; 
end
else
begin
  sym := _noSym;
exit;
end;
   4: begin
sym := enttext_Sym;
exit;
end;
   5: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '#') OR
(CurrInputCh >= '%') AND (CurrInputCh <= CHR(39)) OR
(CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ';') OR
(CurrInputCh >= '?') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '\') OR
(CurrInputCh >= '^') AND (CurrInputCh <= CHR(127)) OR
(CurrInputCh >= CHR(129)) AND (CurrInputCh <= CHR(162)) OR
(CurrInputCh = CHR(164)) OR
(CurrInputCh >= CHR(166))) then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: begin
sym := literal_Sym;
exit;
end;
   7: begin
sym := operator_Sym;
exit;
end;
   8: begin
sym := minus_Sym;
exit;
end;
   9: begin
sym := dollar_Sym;
exit;
end;
  10: begin
sym := paren_Sym;
exit;
end;
  11: begin
sym := rparen_Sym;
exit;
end;
  12: begin
sym := lparen_Sym;
exit;
end;
  13: begin
sym := _lbraceSym;
exit;
end;
  14: begin
sym := _rbraceSym;
exit;
end;
  15: if (CurrInputCh = 'I') then
begin
state := 16; 
end
else if (CurrInputCh = 'D') then
begin
state := 21; 
end
else if (CurrInputCh = 'S') then
begin
state := 27; 
end
else if (CurrInputCh = 'O') then
begin
state := 33; 
end
else if (CurrInputCh = 'U') then
begin
state := 43; 
end
else if (CurrInputCh = 'L') then
begin
state := 48; 
end
else if (CurrInputCh = 'C') then
begin
state := 53; 
end
else if (CurrInputCh = 'P') then
begin
state := 61; 
end
else if (CurrInputCh = 'B') then
begin
state := 68; 
end
else if (CurrInputCh = 'V') then
begin
state := 75; 
end
else if (CurrInputCh = 'G') then
begin
state := 83; 
end
else if (CurrInputCh = 'H') then
begin
state := 95; 
end
else if (CurrInputCh = 'A') then
begin
state := 103; 
end
else if (CurrInputCh = 'N') then
begin
state := 108; 
end
else if (CurrInputCh = 'R') then
begin
state := 148; 
end
else if (CurrInputCh = 'T') then
begin
state := 166; 
end
else if (CurrInputCh = 'M') then
begin
state := 189; 
end
else
begin
  sym := _noSym;
exit;
end;
  16: if (CurrInputCh = 'N') then
begin
state := 17; 
end
else
begin
sym := _atISym;
exit;
end;
  17: if (CurrInputCh = 'P') then
begin
state := 18; 
end
else if (CurrInputCh = 'T') then
begin
state := 245; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if (CurrInputCh = 'U') then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if (CurrInputCh = 'T') then
begin
state := 20; 
end
else
begin
  sym := _noSym;
exit;
end;
  20: begin
sym := _atINPUTSym;
exit;
end;
  21: if (CurrInputCh = 'I') then
begin
state := 22; 
end
else if (CurrInputCh = 'B') then
begin
state := 88; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: if (CurrInputCh = 'V') then
begin
state := 23; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: if (CurrInputCh = 'S') then
begin
state := 25; 
end
else
begin
sym := _atDIVSym;
exit;
end;
  24: begin
sym := _semicolonSym;
exit;
end;
  25: if (CurrInputCh = 'M') then
begin
state := 26; 
end
else
begin
  sym := _noSym;
exit;
end;
  26: begin
sym := _atDIVSMSym;
exit;
end;
  27: if (CurrInputCh = 'U') then
begin
state := 28; 
end
else if (CurrInputCh = 'I') then
begin
state := 116; 
end
else if (CurrInputCh = 'Y') then
begin
state := 119; 
end
else if (CurrInputCh = 'L') then
begin
state := 160; 
end
else
begin
  sym := _noSym;
exit;
end;
  28: if (CurrInputCh = 'P') then
begin
state := 29; 
end
else if (CurrInputCh = 'B') then
begin
state := 209; 
end
else if (CurrInputCh = 'M') then
begin
state := 251; 
end
else
begin
  sym := _noSym;
exit;
end;
  29: if (CurrInputCh = 'S') then
begin
state := 30; 
end
else
begin
sym := _atSUPSym;
exit;
end;
  30: if (CurrInputCh = 'U') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  31: if (CurrInputCh = 'B') then
begin
state := 32; 
end
else
begin
  sym := _noSym;
exit;
end;
  32: begin
sym := _atSUPSUBSym;
exit;
end;
  33: if (CurrInputCh = 'V') then
begin
state := 34; 
end
else
begin
  sym := _noSym;
exit;
end;
  34: if (CurrInputCh = 'E') then
begin
state := 35; 
end
else if (CurrInputCh = 'D') then
begin
state := 131; 
end
else
begin
  sym := _noSym;
exit;
end;
  35: if (CurrInputCh = 'R') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  36: if (CurrInputCh = 'U') then
begin
state := 37; 
end
else if (CurrInputCh = 'B') then
begin
state := 124; 
end
else
begin
sym := _atOVERSym;
exit;
end;
  37: if (CurrInputCh = 'N') then
begin
state := 38; 
end
else
begin
  sym := _noSym;
exit;
end;
  38: if (CurrInputCh = 'D') then
begin
state := 39; 
end
else
begin
  sym := _noSym;
exit;
end;
  39: if (CurrInputCh = 'E') then
begin
state := 40; 
end
else if (CurrInputCh = 'R') then
begin
state := 42; 
end
else
begin
  sym := _noSym;
exit;
end;
  40: if (CurrInputCh = 'R') then
begin
state := 41; 
end
else
begin
  sym := _noSym;
exit;
end;
  41: begin
sym := _atOVERUNDERSym;
exit;
end;
  42: begin
sym := _atOVERUNDRSym;
exit;
end;
  43: if (CurrInputCh = 'N') then
begin
state := 44; 
end
else if (CurrInputCh = 'M') then
begin
state := 176; 
end
else
begin
  sym := _noSym;
exit;
end;
  44: if (CurrInputCh = 'D') then
begin
state := 45; 
end
else
begin
  sym := _noSym;
exit;
end;
  45: if (CurrInputCh = 'E') then
begin
state := 46; 
end
else if (CurrInputCh = 'R') then
begin
state := 127; 
end
else if (CurrInputCh = 'B') then
begin
state := 136; 
end
else
begin
  sym := _noSym;
exit;
end;
  46: if (CurrInputCh = 'R') then
begin
state := 47; 
end
else
begin
  sym := _noSym;
exit;
end;
  47: begin
sym := _atUNDERSym;
exit;
end;
  48: if (CurrInputCh = 'D') then
begin
state := 49; 
end
else
begin
  sym := _noSym;
exit;
end;
  49: if (CurrInputCh = 'I') then
begin
state := 50; 
end
else
begin
  sym := _noSym;
exit;
end;
  50: if (CurrInputCh = 'V') then
begin
state := 51; 
end
else
begin
  sym := _noSym;
exit;
end;
  51: if (CurrInputCh = 'Q') then
begin
state := 52; 
end
else
begin
sym := _atLDIVSym;
exit;
end;
  52: begin
sym := _atLDIVQSym;
exit;
end;
  53: if (CurrInputCh = 'B') then
begin
state := 54; 
end
else if (CurrInputCh = 'I') then
begin
state := 114; 
end
else if (CurrInputCh = 'N') then
begin
state := 198; 
end
else if (CurrInputCh = 'U') then
begin
state := 201; 
end
else if (CurrInputCh = 'H') then
begin
state := 213; 
end
else if (CurrInputCh = 'O') then
begin
state := 231; 
end
else
begin
  sym := _noSym;
exit;
end;
  54: if (CurrInputCh = 'R') then
begin
state := 55; 
end
else
begin
  sym := _noSym;
exit;
end;
  55: if (CurrInputCh = 'A') then
begin
state := 56; 
end
else
begin
  sym := _noSym;
exit;
end;
  56: if (CurrInputCh = 'C') then
begin
state := 57; 
end
else
begin
  sym := _noSym;
exit;
end;
  57: if (CurrInputCh = 'E') then
begin
state := 58; 
end
else
begin
  sym := _noSym;
exit;
end;
  58: if (CurrInputCh = 'L') then
begin
state := 59; 
end
else if (CurrInputCh = 'R') then
begin
state := 60; 
end
else
begin
sym := _atCBRACESym;
exit;
end;
  59: begin
sym := _atCBRACELSym;
exit;
end;
  60: begin
sym := _atCBRACERSym;
exit;
end;
  61: if (CurrInputCh = 'A') then
begin
state := 62; 
end
else if (CurrInputCh = 'R') then
begin
state := 181; 
end
else
begin
  sym := _noSym;
exit;
end;
  62: if (CurrInputCh = 'R') then
begin
state := 63; 
end
else
begin
  sym := _noSym;
exit;
end;
  63: if (CurrInputCh = 'E') then
begin
state := 64; 
end
else
begin
  sym := _noSym;
exit;
end;
  64: if (CurrInputCh = 'N') then
begin
state := 65; 
end
else
begin
  sym := _noSym;
exit;
end;
  65: if (CurrInputCh = 'L') then
begin
state := 66; 
end
else if (CurrInputCh = 'R') then
begin
state := 67; 
end
else
begin
sym := _atPARENSym;
exit;
end;
  66: begin
sym := _atPARENLSym;
exit;
end;
  67: begin
sym := _atPARENRSym;
exit;
end;
  68: if (CurrInputCh = 'R') then
begin
state := 69; 
end
else
begin
sym := _atBSym;
exit;
end;
  69: if (CurrInputCh = 'A') then
begin
state := 70; 
end
else
begin
  sym := _noSym;
exit;
end;
  70: if (CurrInputCh = 'C') then
begin
state := 71; 
end
else
begin
  sym := _noSym;
exit;
end;
  71: if (CurrInputCh = 'E') then
begin
state := 72; 
end
else
begin
  sym := _noSym;
exit;
end;
  72: if (CurrInputCh = 'L') then
begin
state := 73; 
end
else if (CurrInputCh = 'R') then
begin
state := 74; 
end
else
begin
sym := _atBRACESym;
exit;
end;
  73: begin
sym := _atBRACELSym;
exit;
end;
  74: begin
sym := _atBRACERSym;
exit;
end;
  75: if (CurrInputCh = 'E') then
begin
state := 76;
end
else if (CurrInputCh = 'A') then
begin
state := 256;
end
else
begin
  sym := _noSym;
exit;
end;
  76: if (CurrInputCh = 'C') then
begin
state := 77; 
end
else
begin
  sym := _noSym;
exit;
end;
  77: if (CurrInputCh = 'T') then
begin
state := 78; 
end
else
begin
  sym := _noSym;
exit;
end;
  78: if (CurrInputCh = 'O') then
begin
state := 79; 
end
else
begin
  sym := _noSym;
exit;
end;
  79: if (CurrInputCh = 'R') then
begin
state := 80; 
end
else
begin
  sym := _noSym;
exit;
end;
  80: if (CurrInputCh = 'L') then
begin
state := 81; 
end
else if (CurrInputCh = 'R') then
begin
state := 82; 
end
else
begin
sym := _atVECTORSym;
exit;
end;
  81: begin
sym := _atVECTORLSym;
exit;
end;
  82: begin
sym := _atVECTORRSym;
exit;
end;
  83: if (CurrInputCh = 'R') then
begin
state := 84; 
end
else
begin
  sym := _noSym;
exit;
end;
  84: if (CurrInputCh = 'I') then
begin
state := 85; 
end
else
begin
  sym := _noSym;
exit;
end;
  85: if (CurrInputCh = 'N') then
begin
state := 86; 
end
else
begin
  sym := _noSym;
exit;
end;
  86: if (CurrInputCh = 'T') then
begin
state := 87; 
end
else
begin
  sym := _noSym;
exit;
end;
  87: begin
sym := _atGRINTSym;
exit;
end;
  88: if (CurrInputCh = 'R') then
begin
state := 89; 
end
else
begin
  sym := _noSym;
exit;
end;
  89: if (CurrInputCh = 'A') then
begin
state := 90; 
end
else
begin
  sym := _noSym;
exit;
end;
  90: if (CurrInputCh = 'C') then
begin
state := 91; 
end
else
begin
  sym := _noSym;
exit;
end;
  91: if (CurrInputCh = 'E') then
begin
state := 92; 
end
else
begin
  sym := _noSym;
exit;
end;
  92: if (CurrInputCh = 'L') then
begin
state := 93; 
end
else if (CurrInputCh = 'R') then
begin
state := 94; 
end
else
begin
  sym := _noSym;
exit;
end;
  93: begin
sym := _atDBRACELSym;
exit;
end;
  94: begin
sym := _atDBRACERSym;
exit;
end;
  95: if (CurrInputCh = 'B') then
begin
state := 96; 
end
else if (CurrInputCh = 'A') then
begin
state := 164; 
end
else
begin
  sym := _noSym;
exit;
end;
  96: if (CurrInputCh = 'R') then
begin
state := 97; 
end
else
begin
  sym := _noSym;
exit;
end;
  97: if (CurrInputCh = 'A') then
begin
state := 98; 
end
else
begin
  sym := _noSym;
exit;
end;
  98: if (CurrInputCh = 'C') then
begin
state := 99; 
end
else
begin
  sym := _noSym;
exit;
end;
  99: if (CurrInputCh = 'E') then
begin
state := 100; 
end
else
begin
  sym := _noSym;
exit;
end;
  100: if (CurrInputCh = 'T') then
begin
state := 101; 
end
else if (CurrInputCh = 'B') then
begin
state := 102; 
end
else
begin
sym := _atHBRACESym;
exit;
end;
  101: begin
sym := _atHBRACETSym;
exit;
end;
  102: begin
sym := _atHBRACEBSym;
exit;
end;
  103: if (CurrInputCh = 'B') then
begin
state := 104; 
end
else if (CurrInputCh = 'R') then
begin
state := 140; 
end
else if (CurrInputCh = 'C') then
begin
state := 171; 
end
else if (CurrInputCh = 'U') then
begin
state := 219; 
end
else
begin
  sym := _noSym;
exit;
end;
  104: if (CurrInputCh = 'S') then
begin
state := 105; 
end
else
begin
  sym := _noSym;
exit;
end;
  105: if (CurrInputCh = 'L') then
begin
state := 106; 
end
else if (CurrInputCh = 'R') then
begin
state := 107; 
end
else
begin
sym := _atABSSym;
exit;
end;
  106: begin
sym := _atABSLSym;
exit;
end;
  107: begin
sym := _atABSRSym;
exit;
end;
  108: if (CurrInputCh = 'O') then
begin
state := 109; 
end
else if (CurrInputCh = 'U') then
begin
state := 195; 
end
else if (CurrInputCh = 'E') then
begin
state := 204; 
end
else
begin
  sym := _noSym;
exit;
end;
  109: if (CurrInputCh = 'R') then
begin
state := 110; 
end
else
begin
  sym := _noSym;
exit;
end;
  110: if (CurrInputCh = 'M') then
begin
state := 111; 
end
else
begin
  sym := _noSym;
exit;
end;
  111: if (CurrInputCh = 'L') then
begin
state := 112; 
end
else if (CurrInputCh = 'R') then
begin
state := 113; 
end
else
begin
sym := _atNORMSym;
exit;
end;
  112: begin
sym := _atNORMLSym;
exit;
end;
  113: begin
sym := _atNORMRSym;
exit;
end;
  114: if (CurrInputCh = 'S') then
begin
state := 115; 
end
else
begin
  sym := _noSym;
exit;
end;
  115: begin
sym := _atCISSym;
exit;
end;
  116: if (CurrInputCh = 'Z') then
begin
state := 117; 
end
else
begin
  sym := _noSym;
exit;
end;
  117: if (CurrInputCh = 'E') then
begin
state := 118; 
end
else
begin
  sym := _noSym;
exit;
end;
  118: begin
sym := _atSIZESym;
exit;
end;
  119: if (CurrInputCh = 'N') then
begin
state := 120; 
end
else
begin
  sym := _noSym;
exit;
end;
  120: if (CurrInputCh = 'D') then
begin
state := 121; 
end
else
begin
  sym := _noSym;
exit;
end;
  121: if (CurrInputCh = 'I') then
begin
state := 122; 
end
else
begin
  sym := _noSym;
exit;
end;
  122: if (CurrInputCh = 'V') then
begin
state := 123; 
end
else
begin
  sym := _noSym;
exit;
end;
  123: begin
sym := _atSYNDIVSym;
exit;
end;
  124: if (CurrInputCh = 'A') then
begin
state := 125; 
end
else if (CurrInputCh = 'R') then
begin
state := 155; 
end
else
begin
  sym := _noSym;
exit;
end;
  125: if (CurrInputCh = 'R') then
begin
state := 126; 
end
else
begin
  sym := _noSym;
exit;
end;
  126: begin
sym := _atOVERBARSym;
exit;
end;
  127: if (CurrInputCh = 'B') then
begin
state := 128; 
end
else
begin
  sym := _noSym;
exit;
end;
  128: if (CurrInputCh = 'A') then
begin
state := 129; 
end
else if (CurrInputCh = 'R') then
begin
state := 157; 
end
else
begin
  sym := _noSym;
exit;
end;
  129: if (CurrInputCh = 'R') then
begin
state := 130; 
end
else
begin
  sym := _noSym;
exit;
end;
  130: begin
sym := _atUNDRBARSym;
exit;
end;
  131: if (CurrInputCh = 'B') then
begin
state := 132; 
end
else
begin
  sym := _noSym;
exit;
end;
  132: if (CurrInputCh = 'B') then
begin
state := 133; 
end
else
begin
  sym := _noSym;
exit;
end;
  133: if (CurrInputCh = 'A') then
begin
state := 134; 
end
else
begin
  sym := _noSym;
exit;
end;
  134: if (CurrInputCh = 'R') then
begin
state := 135; 
end
else
begin
  sym := _noSym;
exit;
end;
  135: begin
sym := _atOVDBBARSym;
exit;
end;
  136: if (CurrInputCh = 'B') then
begin
state := 137; 
end
else
begin
  sym := _noSym;
exit;
end;
  137: if (CurrInputCh = 'A') then
begin
state := 138; 
end
else
begin
  sym := _noSym;
exit;
end;
  138: if (CurrInputCh = 'R') then
begin
state := 139; 
end
else
begin
  sym := _noSym;
exit;
end;
  139: begin
sym := _atUNDBBARSym;
exit;
end;
  140: if (CurrInputCh = 'R') then
begin
state := 141; 
end
else if (CurrInputCh = 'C') then
begin
state := 159; 
end
else
begin
  sym := _noSym;
exit;
end;
  141: if (CurrInputCh = 'O') then
begin
state := 142; 
end
else
begin
  sym := _noSym;
exit;
end;
  142: if (CurrInputCh = 'W') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  143: if (CurrInputCh = 'L') then
begin
state := 144; 
end
else if (CurrInputCh = 'R') then
begin
state := 145; 
end
else if (CurrInputCh = 'D') then
begin
state := 146; 
end
else
begin
  sym := _noSym;
exit;
end;
  144: begin
sym := _atARROWLSym;
exit;
end;
  145: begin
sym := _atARROWRSym;
exit;
end;
  146: if (CurrInputCh = 'B') then
begin
state := 147; 
end
else
begin
  sym := _noSym;
exit;
end;
  147: begin
sym := _atARROWDBSym;
exit;
end;
  148: if (CurrInputCh = 'A') then
begin
state := 149; 
end
else if (CurrInputCh = 'E') then
begin
state := 187; 
end
else if (CurrInputCh = 'T') then
begin
state := 207; 
end
else if (CurrInputCh = 'O') then
begin
state := 227; 
end
else
begin
  sym := _noSym;
exit;
end;
  149: if (CurrInputCh = 'Y') then
begin
state := 150; 
end
else
begin
  sym := _noSym;
exit;
end;
  150: if (CurrInputCh = 'L') then
begin
state := 151; 
end
else if (CurrInputCh = 'R') then
begin
state := 152; 
end
else if (CurrInputCh = 'D') then
begin
state := 153; 
end
else
begin
  sym := _noSym;
exit;
end;
  151: begin
sym := _atRAYLSym;
exit;
end;
  152: begin
sym := _atRAYRSym;
exit;
end;
  153: if (CurrInputCh = 'B') then
begin
state := 154; 
end
else
begin
  sym := _noSym;
exit;
end;
  154: begin
sym := _atRAYDBSym;
exit;
end;
  155: if (CurrInputCh = 'C') then
begin
state := 156; 
end
else
begin
  sym := _noSym;
exit;
end;
  156: begin
sym := _atOVERBRCSym;
exit;
end;
  157: if (CurrInputCh = 'C') then
begin
state := 158; 
end
else
begin
  sym := _noSym;
exit;
end;
  158: begin
sym := _atUNDRBRCSym;
exit;
end;
  159: begin
sym := _atARCSym;
exit;
end;
  160: if (CurrInputCh = 'A') then
begin
state := 161; 
end
else
begin
  sym := _noSym;
exit;
end;
  161: if (CurrInputCh = 'S') then
begin
state := 162; 
end
else
begin
  sym := _noSym;
exit;
end;
  162: if (CurrInputCh = 'H') then
begin
state := 163; 
end
else
begin
  sym := _noSym;
exit;
end;
  163: begin
sym := _atSLASHSym;
exit;
end;
  164: if (CurrInputCh = 'T') then
begin
state := 165; 
end
else
begin
  sym := _noSym;
exit;
end;
  165: begin
sym := _atHATSym;
exit;
end;
  166: if (CurrInputCh = 'I') then
begin
state := 167; 
end
else if (CurrInputCh = 'A') then
begin
state := 238; 
end
else
begin
sym := _atTSym;
exit;
end;
  167: if (CurrInputCh = 'L') then
begin
state := 168; 
end
else
begin
  sym := _noSym;
exit;
end;
  168: if (CurrInputCh = 'D') then
begin
state := 169; 
end
else
begin
  sym := _noSym;
exit;
end;
  169: if (CurrInputCh = 'E') then
begin
state := 170; 
end
else
begin
  sym := _noSym;
exit;
end;
  170: begin
sym := _atTILDESym;
exit;
end;
  171: if (CurrInputCh = 'C') then
begin
state := 172; 
end
else
begin
  sym := _noSym;
exit;
end;
  172: if (CurrInputCh = 'E') then
begin
state := 173; 
end
else
begin
  sym := _noSym;
exit;
end;
  173: if (CurrInputCh = 'N') then
begin
state := 174; 
end
else
begin
  sym := _noSym;
exit;
end;
  174: if (CurrInputCh = 'T') then
begin
state := 175; 
end
else
begin
  sym := _noSym;
exit;
end;
  175: begin
sym := _atACCENTSym;
exit;
end;
  176: if (CurrInputCh = 'L') then
begin
state := 177; 
end
else
begin
  sym := _noSym;
exit;
end;
  177: if (CurrInputCh = 'A') then
begin
state := 178; 
end
else
begin
  sym := _noSym;
exit;
end;
  178: if (CurrInputCh = 'U') then
begin
state := 179; 
end
else
begin
  sym := _noSym;
exit;
end;
  179: if (CurrInputCh = 'T') then
begin
state := 180; 
end
else
begin
  sym := _noSym;
exit;
end;
  180: begin
sym := _atUMLAUTSym;
exit;
end;
  181: if (CurrInputCh = 'I') then
begin
state := 182; 
end
else
begin
  sym := _noSym;
exit;
end;
  182: if (CurrInputCh = 'M') then
begin
state := 183; 
end
else
begin
  sym := _noSym;
exit;
end;
  183: if (CurrInputCh = 'E') then
begin
state := 184; 
end
else
begin
  sym := _noSym;
exit;
end;
  184: if (CurrInputCh = '2') then
begin
state := 185; 
end
else if (CurrInputCh = '3') then
begin
state := 186; 
end
else
begin
sym := _atPRIMESym;
exit;
end;
  185: begin
sym := _atPRIME_twoSym;
exit;
end;
  186: begin
sym := _atPRIME_threeSym;
exit;
end;
  187: if (CurrInputCh = 'P') then
begin
state := 188; 
end
else
begin
  sym := _noSym;
exit;
end;
  188: begin
sym := _atREPSym;
exit;
end;
  189: if (CurrInputCh = 'N') then
begin
state := 190; 
end
else if (CurrInputCh = 'I') then
begin
state := 193; 
end
else if (CurrInputCh = 'A') then
begin
state := 211; 
end
else
begin
  sym := _noSym;
exit;
end;
  190: if (CurrInputCh = 'U') then
begin
state := 191; 
end
else
begin
  sym := _noSym;
exit;
end;
  191: if (CurrInputCh = 'M') then
begin
state := 192; 
end
else
begin
  sym := _noSym;
exit;
end;
  192: begin
sym := _atMNUMSym;
exit;
end;
  193: if (CurrInputCh = 'X') then
begin
state := 194; 
end
else
begin
  sym := _noSym;
exit;
end;
  194: begin
sym := _atMIXSym;
exit;
end;
  195: if (CurrInputCh = 'M') then
begin
state := 196; 
end
else
begin
  sym := _noSym;
exit;
end;
  196: begin
sym := _atNUMSym;
exit;
end;
  197: begin
sym := NUM_lparenSym;
exit;
end;
  198: if (CurrInputCh = 'U') then
begin
state := 199; 
end
else
begin
  sym := _noSym;
exit;
end;
  199: if (CurrInputCh = 'M') then
begin
state := 200; 
end
else
begin
  sym := _noSym;
exit;
end;
  200: begin
sym := _atCNUMSym;
exit;
end;
  201: if (CurrInputCh = 'R') then
begin
state := 202; 
end
else
begin
  sym := _noSym;
exit;
end;
  202: if (CurrInputCh = 'R') then
begin
state := 203; 
end
else
begin
  sym := _noSym;
exit;
end;
  203: begin
sym := _atCURRSym;
exit;
end;
  204: if (CurrInputCh = 'G') then
begin
state := 205; 
end
else
begin
  sym := _noSym;
exit;
end;
  205: if (CurrInputCh = 'P') then
begin
state := 206; 
end
else
begin
  sym := _noSym;
exit;
end;
  206: begin
sym := _atNEGPSym;
exit;
end;
  207: begin
sym := _atRTSym;
exit;
end;
  208: begin
sym := _uparrowSym;
exit;
end;
  209: begin
sym := _atSUBSym;
exit;
end;
  210: begin
sym := _underscoreSym;
exit;
end;
  211: if (CurrInputCh = 'T') then
begin
state := 212; 
end
else
begin
  sym := _noSym;
exit;
end;
  212: if (CurrInputCh = 'L') then
begin
state := 217; 
end
else if (CurrInputCh = 'R') then
begin
state := 218; 
end
else
begin
sym := _atMATSym;
exit;
end;
  213: if (CurrInputCh = 'E') then
begin
state := 214; 
end
else
begin
  sym := _noSym;
exit;
end;
  214: if (CurrInputCh = 'C') then
begin
state := 215; 
end
else
begin
  sym := _noSym;
exit;
end;
  215: if (CurrInputCh = 'K') then
begin
state := 216; 
end
else
begin
  sym := _noSym;
exit;
end;
  216: begin
sym := _atCHECKSym;
exit;
end;
  217: begin
sym := _atMATLSym;
exit;
end;
  218: begin
sym := _atMATRSym;
exit;
end;
  219: if (CurrInputCh = 'G') then
begin
state := 220; 
end
else
begin
  sym := _noSym;
exit;
end;
  220: if (CurrInputCh = 'M') then
begin
state := 221; 
end
else
begin
  sym := _noSym;
exit;
end;
  221: if (CurrInputCh = 'E') then
begin
state := 222; 
end
else
begin
  sym := _noSym;
exit;
end;
  222: if (CurrInputCh = 'N') then
begin
state := 223; 
end
else
begin
  sym := _noSym;
exit;
end;
  223: if (CurrInputCh = 'T') then
begin
state := 224; 
end
else
begin
  sym := _noSym;
exit;
end;
  224: if (CurrInputCh = 'L') then
begin
state := 225; 
end
else if (CurrInputCh = 'R') then
begin
state := 226; 
end
else
begin
sym := _atAUGMENTSym;
exit;
end;
  225: begin
sym := _atAUGMENTLSym;
exit;
end;
  226: begin
sym := _atAUGMENTRSym;
exit;
end;
  227: if (CurrInputCh = 'W') then
begin
state := 228; 
end
else
begin
  sym := _noSym;
exit;
end;
  228: if (CurrInputCh = 'L') then
begin
state := 229; 
end
else if (CurrInputCh = 'R') then
begin
state := 230; 
end
else
begin
sym := _atROWSym;
exit;
end;
  229: begin
sym := _atROWLSym;
exit;
end;
  230: begin
sym := _atROWRSym;
exit;
end;
  231: if (CurrInputCh = 'L') then
begin
state := 232; 
end
else
begin
  sym := _noSym;
exit;
end;
  232: if (CurrInputCh = 'U') then
begin
state := 233; 
end
else
begin
  sym := _noSym;
exit;
end;
  233: if (CurrInputCh = 'M') then
begin
state := 234; 
end
else
begin
  sym := _noSym;
exit;
end;
  234: if (CurrInputCh = 'N') then
begin
state := 235; 
end
else
begin
  sym := _noSym;
exit;
end;
  235: if (CurrInputCh = 'L') then
begin
state := 236; 
end
else if (CurrInputCh = 'R') then
begin
state := 237; 
end
else
begin
sym := _atCOLUMNSym;
exit;
end;
  236: begin
sym := _atCOLUMNLSym;
exit;
end;
  237: begin
sym := _atCOLUMNRSym;
exit;
end;
  238: if (CurrInputCh = 'B') then
begin
state := 239; 
end
else
begin
  sym := _noSym;
exit;
end;
  239: if (CurrInputCh = 'L') then
begin
state := 240; 
end
else if (CurrInputCh = 'R') then
begin
state := 241; 
end
else
begin
sym := _atTABSym;
exit;
end;
  240: if (CurrInputCh = 'E') then
begin
state := 242; 
end
else
begin
sym := _atTABLSym;
exit;
end;
  241: begin
sym := _atTABRSym;
exit;
end;
  242: if (CurrInputCh = 'L') then
begin
state := 243; 
end
else if (CurrInputCh = 'R') then
begin
state := 244; 
end
else
begin
sym := _atTABLESym;
exit;
end;
  243: begin
sym := _atTABLELSym;
exit;
end;
  244: begin
sym := _atTABLERSym;
exit;
end;
  245: if (CurrInputCh = 'E') then
begin
state := 246;
end
else
begin
  sym := _noSym;
exit;
end;
  246: if (CurrInputCh = 'G') then
begin
state := 247; 
end
else
begin
  sym := _noSym;
exit;
end;
  247: if (CurrInputCh = 'R') then
begin
state := 248; 
end
else
begin
  sym := _noSym;
exit;
end;
  248: if (CurrInputCh = 'A') then
begin
state := 249; 
end
else
begin
  sym := _noSym;
exit;
end;
  249: if (CurrInputCh = 'L') then
begin
state := 250; 
end
else
begin
  sym := _noSym;
exit;
end;
  250: begin
sym := _atINTEGRALSym;
exit;
end;
  251: begin
sym := _atSUMSym;
exit;
end;
  252: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '#') OR
(CurrInputCh = '%') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh = '?') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'T') OR
(CurrInputCh >= 'V') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= '`') AND (CurrInputCh <= 'z') OR
(CurrInputCh = '|') OR
(CurrInputCh >= '~') AND (CurrInputCh <= CHR(127)) OR
(CurrInputCh >= CHR(129)) AND (CurrInputCh <= CHR(162)) OR
(CurrInputCh = CHR(164)) OR
(CurrInputCh >= CHR(166))) then
begin
state := 1; 
end
else if (CurrInputCh = 'U') then
begin
state := 253; 
end
else
begin
sym := text_Sym;
exit;
end;
  253: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '#') OR
(CurrInputCh = '%') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh = '?') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'L') OR
(CurrInputCh >= 'N') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= '`') AND (CurrInputCh <= 'z') OR
(CurrInputCh = '|') OR
(CurrInputCh >= '~') AND (CurrInputCh <= CHR(127)) OR
(CurrInputCh >= CHR(129)) AND (CurrInputCh <= CHR(162)) OR
(CurrInputCh = CHR(164)) OR
(CurrInputCh >= CHR(166))) then
begin
state := 1; 
end
else if (CurrInputCh = 'M') then
begin
state := 254; 
end
else
begin
sym := text_Sym;
exit;
end;
  254: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '#') OR
(CurrInputCh = '%') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh = '?') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= '`') AND (CurrInputCh <= 'z') OR
(CurrInputCh = '|') OR
(CurrInputCh >= '~') AND (CurrInputCh <= CHR(127)) OR
(CurrInputCh >= CHR(129)) AND (CurrInputCh <= CHR(162)) OR
(CurrInputCh = CHR(164)) OR
(CurrInputCh >= CHR(166))) then
begin
state := 1; 
end
else if (CurrInputCh = '(') then
begin
state := 197; 
end
else
begin
sym := text_Sym;
exit;
end;
  255: begin
sym := EOFSYMB;
CurrInputCh := #0;
BufferPosition := BufferPosition - 1;
exit
end;
  256: begin
if (CurrInputCh = 'R') then
begin
state := 257;
end
else
begin
sym := _noSym;
exit;
end;
end;
  257: begin
sym := _atVARSym;
exit;
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TIPEqParserScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(ITinyHash, HashSecondaryOne, SameText);
CurrentCh := CapChAt;
fStartState[  0] := 255; fStartState[  1] := 256; fStartState[  2] := 256; fStartState[  3] := 256; 
fStartState[  4] := 256; fStartState[  5] := 256; fStartState[  6] := 256; fStartState[  7] := 256; 
fStartState[  8] := 256; fStartState[  9] := 256; fStartState[ 10] := 256; fStartState[ 11] := 256; 
fStartState[ 12] := 256; fStartState[ 13] := 256; fStartState[ 14] := 256; fStartState[ 15] := 256; 
fStartState[ 16] := 256; fStartState[ 17] := 256; fStartState[ 18] := 256; fStartState[ 19] := 256; 
fStartState[ 20] := 256; fStartState[ 21] := 256; fStartState[ 22] := 256; fStartState[ 23] := 256; 
fStartState[ 24] := 256; fStartState[ 25] := 256; fStartState[ 26] := 256; fStartState[ 27] := 256; 
fStartState[ 28] := 256; fStartState[ 29] := 256; fStartState[ 30] := 256; fStartState[ 31] := 256; 
fStartState[ 32] :=  1; fStartState[ 33] :=  1; fStartState[ 34] :=  1; fStartState[ 35] :=  1; 
fStartState[ 36] :=  9; fStartState[ 37] :=  1; fStartState[ 38] :=  2; fStartState[ 39] :=  1; 
fStartState[ 40] := 12; fStartState[ 41] := 11; fStartState[ 42] :=  7; fStartState[ 43] :=  7; 
fStartState[ 44] :=  7; fStartState[ 45] :=  8; fStartState[ 46] :=  1; fStartState[ 47] :=  7; 
fStartState[ 48] :=  1; fStartState[ 49] :=  1; fStartState[ 50] :=  1; fStartState[ 51] :=  1; 
fStartState[ 52] :=  1; fStartState[ 53] :=  1; fStartState[ 54] :=  1; fStartState[ 55] :=  1; 
fStartState[ 56] :=  1; fStartState[ 57] :=  1; fStartState[ 58] :=  1; fStartState[ 59] := 24; 
fStartState[ 60] :=  7; fStartState[ 61] :=  7; fStartState[ 62] :=  7; fStartState[ 63] :=  1; 
fStartState[ 64] := 15; fStartState[ 65] :=  1; fStartState[ 66] :=  1; fStartState[ 67] :=  1;
fStartState[ 68] :=  1; fStartState[ 69] :=  1; fStartState[ 70] :=  1; fStartState[ 71] :=  1; 
fStartState[ 72] :=  1; fStartState[ 73] :=  1; fStartState[ 74] :=  1; fStartState[ 75] :=  1; 
fStartState[ 76] :=  1; fStartState[ 77] :=  1; fStartState[ 78] := 252; fStartState[ 79] :=  1; 
fStartState[ 80] :=  1; fStartState[ 81] :=  1; fStartState[ 82] :=  1; fStartState[ 83] :=  1; 
fStartState[ 84] :=  1; fStartState[ 85] :=  1; fStartState[ 86] :=  1; fStartState[ 87] :=  1; 
fStartState[ 88] :=  1; fStartState[ 89] :=  1; fStartState[ 90] :=  1; fStartState[ 91] := 10; 
fStartState[ 92] :=  5; fStartState[ 93] := 10; fStartState[ 94] := 208; fStartState[ 95] := 210; 
fStartState[ 96] :=  1; fStartState[ 97] :=  1; fStartState[ 98] :=  1; fStartState[ 99] :=  1; 
fStartState[100] :=  1; fStartState[101] :=  1; fStartState[102] :=  1; fStartState[103] :=  1; 
fStartState[104] :=  1; fStartState[105] :=  1; fStartState[106] :=  1; fStartState[107] :=  1; 
fStartState[108] :=  1; fStartState[109] :=  1; fStartState[110] :=  1; fStartState[111] :=  1; 
fStartState[112] :=  1; fStartState[113] :=  1; fStartState[114] :=  1; fStartState[115] :=  1; 
fStartState[116] :=  1; fStartState[117] :=  1; fStartState[118] :=  1; fStartState[119] :=  1; 
fStartState[120] :=  1; fStartState[121] :=  1; fStartState[122] :=  1; fStartState[123] := 13; 
fStartState[124] :=  1; fStartState[125] := 14; fStartState[126] :=  1; fStartState[127] :=  1; 
fStartState[128] :=  9; fStartState[129] :=  1; fStartState[130] :=  1; fStartState[131] :=  1; 
fStartState[132] :=  1; fStartState[133] :=  1; fStartState[134] :=  1; fStartState[135] :=  1; 
fStartState[136] :=  1; fStartState[137] :=  1; fStartState[138] :=  1; fStartState[139] :=  1; 
fStartState[140] :=  1; fStartState[141] :=  1; fStartState[142] :=  1; fStartState[143] :=  1; 
fStartState[144] :=  1; fStartState[145] :=  1; fStartState[146] :=  1; fStartState[147] :=  1; 
fStartState[148] :=  1; fStartState[149] :=  1; fStartState[150] :=  1; fStartState[151] :=  1; 
fStartState[152] :=  1; fStartState[153] :=  1; fStartState[154] :=  1; fStartState[155] :=  1; 
fStartState[156] :=  1; fStartState[157] :=  1; fStartState[158] :=  1; fStartState[159] :=  1; 
fStartState[160] :=  1; fStartState[161] :=  1; fStartState[162] :=  1; fStartState[163] :=  9; 
fStartState[164] :=  1; fStartState[165] :=  9; fStartState[166] :=  1; fStartState[167] :=  1; 
fStartState[168] :=  1; fStartState[169] :=  1; fStartState[170] :=  1; fStartState[171] :=  1; 
fStartState[172] :=  1; fStartState[173] :=  1; fStartState[174] :=  1; fStartState[175] :=  1; 
fStartState[176] :=  1; fStartState[177] :=  1; fStartState[178] :=  1; fStartState[179] :=  1; 
fStartState[180] :=  1; fStartState[181] :=  1; fStartState[182] :=  1; fStartState[183] :=  1; 
fStartState[184] :=  1; fStartState[185] :=  1; fStartState[186] :=  1; fStartState[187] :=  1; 
fStartState[188] :=  1; fStartState[189] :=  1; fStartState[190] :=  1; fStartState[191] :=  1; 
fStartState[192] :=  1; fStartState[193] :=  1; fStartState[194] :=  1; fStartState[195] :=  1; 
fStartState[196] :=  1; fStartState[197] :=  1; fStartState[198] :=  1; fStartState[199] :=  1; 
fStartState[200] :=  1; fStartState[201] :=  1; fStartState[202] :=  1; fStartState[203] :=  1; 
fStartState[204] :=  1; fStartState[205] :=  1; fStartState[206] :=  1; fStartState[207] :=  1; 
fStartState[208] :=  1; fStartState[209] :=  1; fStartState[210] :=  1; fStartState[211] :=  1; 
fStartState[212] :=  1; fStartState[213] :=  1; fStartState[214] :=  1; fStartState[215] :=  1; 
fStartState[216] :=  1; fStartState[217] :=  1; fStartState[218] :=  1; fStartState[219] :=  1; 
fStartState[220] :=  1; fStartState[221] :=  1; fStartState[222] :=  1; fStartState[223] :=  1; 
fStartState[224] :=  1; fStartState[225] :=  1; fStartState[226] :=  1; fStartState[227] :=  1; 
fStartState[228] :=  1; fStartState[229] :=  1; fStartState[230] :=  1; fStartState[231] :=  1; 
fStartState[232] :=  1; fStartState[233] :=  1; fStartState[234] :=  1; fStartState[235] :=  1; 
fStartState[236] :=  1; fStartState[237] :=  1; fStartState[238] :=  1; fStartState[239] :=  1; 
fStartState[240] :=  1; fStartState[241] :=  1; fStartState[242] :=  1; fStartState[243] :=  1; 
fStartState[244] :=  1; fStartState[245] :=  1; fStartState[246] :=  1; fStartState[247] :=  1; 
fStartState[248] :=  1; fStartState[249] :=  1; fStartState[250] :=  1; fStartState[251] :=  1; 
fStartState[252] :=  1; fStartState[253] :=  1; fStartState[254] :=  1; fStartState[255] :=  1; 
end; {Create}

destructor TIPEqParserScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TIPEqParser ---- }

constructor TIPEqParser.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TIPEqParserScanner.Create;
  GetScanner.Owner := self;
FNodeList := TObjectList.Create;
  
  InitSymSet;
end; {Create}

destructor TIPEqParser.Destroy;
begin
  Scanner.Free;
FNodeList.Free;
//    FTopRow.Free;                                
  
  inherited;
end; {Destroy}

function TIPEqParser.ErrorStr(const ErrorCode : integer; const Data : string) : string;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'text_ expected';
   2 : Result := 'enttext_ expected';
   3 : Result := 'literal_ expected';
   4 : Result := 'operator_ expected';
   5 : Result := 'minus_ expected';
   6 : Result := 'dollar_ expected';
   7 : Result := 'paren_ expected';
   8 : Result := 'rparen_ expected';
   9 : Result := 'lparen_ expected';
  10 : Result := '"{" expected';
  11 : Result := '"}" expected';
  12 : Result := '"@INPUT" expected';
  13 : Result := '"@DIV" expected';
  14 : Result := '";" expected';
  15 : Result := '"@DIVSM" expected';
  16 : Result := '"@SUPSUB" expected';
  17 : Result := '"@OVERUNDER" expected';
  18 : Result := '"@OVERUNDR" expected';
  19 : Result := '"@OVER" expected';
  20 : Result := '"@UNDER" expected';
  21 : Result := '"@LDIV" expected';
  22 : Result := '"@LDIVQ" expected';
  23 : Result := '"@CBRACE" expected';
  24 : Result := '"@CBRACEL" expected';
  25 : Result := '"@CBRACER" expected';
  26 : Result := '"@PAREN" expected';
  27 : Result := '"@PARENL" expected';
  28 : Result := '"@PARENR" expected';
  29 : Result := '"@BRACE" expected';
  30 : Result := '"@BRACEL" expected';
  31 : Result := '"@BRACER" expected';
  32 : Result := '"@VECTOR" expected';
  33 : Result := '"@VECTORL" expected';
  34 : Result := '"@VECTORR" expected';
  35 : Result := '"@GRINT" expected';
  36 : Result := '"@DBRACEL" expected';
  37 : Result := '"@DBRACER" expected';
  38 : Result := '"@HBRACE" expected';
  39 : Result := '"@HBRACET" expected';
  40 : Result := '"@HBRACEB" expected';
  41 : Result := '"@ABS" expected';
  42 : Result := '"@ABSL" expected';
  43 : Result := '"@ABSR" expected';
  44 : Result := '"@NORM" expected';
  45 : Result := '"@NORML" expected';
  46 : Result := '"@NORMR" expected';
  47 : Result := '"@CIS" expected';
  48 : Result := '"@SIZE" expected';
  49 : Result := '"@SYNDIV" expected';
  50 : Result := '"@OVERBAR" expected';
  51 : Result := '"@UNDRBAR" expected';
  52 : Result := '"@OVDBBAR" expected';
  53 : Result := '"@UNDBBAR" expected';
  54 : Result := '"@ARROWL" expected';
  55 : Result := '"@ARROWR" expected';
  56 : Result := '"@ARROWDB" expected';
  57 : Result := '"@RAYL" expected';
  58 : Result := '"@RAYR" expected';
  59 : Result := '"@RAYDB" expected';
  60 : Result := '"@OVERBRC" expected';
  61 : Result := '"@UNDRBRC" expected';
  62 : Result := '"@ARC" expected';
  63 : Result := '"@SLASH" expected';
  64 : Result := '"@HAT" expected';
  65 : Result := '"@TILDE" expected';
  66 : Result := '"@ACCENT" expected';
  67 : Result := '"@UMLAUT" expected';
  68 : Result := '"@PRIME" expected';
  69 : Result := '"@PRIME2" expected';
  70 : Result := '"@PRIME3" expected';
  71 : Result := '"@REP" expected';
  72 : Result := '"@MNUM" expected';
  73 : Result := '"@MIX" expected';
  74 : Result := '"@NUM" expected';
  75 : Result := '"NUM(" expected';
  76 : Result := '"@CNUM" expected';
  77 : Result := '"@CURR" expected';
  78 : Result := '"@NEGP" expected';
  79 : Result := '"@RT" expected';
  80 : Result := '"@SUP" expected';
  81 : Result := '"^" expected';
  82 : Result := '"@SUB" expected';
  83 : Result := '"_" expected';
  84 : Result := '"@MAT" expected';
  85 : Result := '"@CHECK" expected';
  86 : Result := '"@MATL" expected';
  87 : Result := '"@MATR" expected';
  88 : Result := '"@AUGMENT" expected';
  89 : Result := '"@AUGMENTL" expected';
  90 : Result := '"@AUGMENTR" expected';
  91 : Result := '"@ROW" expected';
  92 : Result := '"@ROWL" expected';
  93 : Result := '"@ROWR" expected';
  94 : Result := '"@COLUMN" expected';
  95 : Result := '"@COLUMNL" expected';
  96 : Result := '"@COLUMNR" expected';
  97 : Result := '"@TAB" expected';
  98 : Result := '"@TABL" expected';
  99 : Result := '"@TABR" expected';
 100 : Result := '"@TABLE" expected';
 101 : Result := '"@TABLEL" expected';
 102 : Result := '"@TABLER" expected';
 103 : Result := '"@INTEGRAL" expected';
 104 : Result := '"@SUM" expected';
 105 : Result := '"@I" expected';
 106 : Result := '"@B" expected';
 107 : Result := '"@T" expected';
 108 : Result := 'not expected';
 109 : Result := 'invalid EqOverUnder';
 110 : Result := 'invalid EqMixedNum';
 111 : Result := 'invalid EqParenChar';
 112 : Result := 'invalid EqOperator';
 113 : Result := 'invalid EqNum3';
 114 : Result := 'invalid EqNum2';
 115 : Result := 'invalid EqSub';
 116 : Result := 'invalid EqSuper';
 117 : Result := 'invalid EqText';
 118 : Result := 'invalid EqNode';

200 : Result := 'Text after end of valid expression';

  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TIPEqParser.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TIPEqParser.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TIPEqParser.GetScanner : TIPEqParserScanner;
begin
  Result := Scanner AS TIPEqParserScanner;
end; {GetScanner}

function TIPEqParser._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TIPEqParser._EqCheckCol (eqCheck:TIPEqCheck);var  eqR:  TIPEqRow;
begin
Expect(_lbraceSym);
eqR  :=  TIPEqRow(eqCheck.AddChild(TIPEqRow.Create));;
_EqRow(eqR);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
eqR  :=  TIPEqRow(eqCheck.AddChild(TIPEqRow.Create));;
_EqRow(eqR);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqMatRow (eqMat:TIPEqMat);var  eqR:TIPEqRow;
begin
Expect(_lbraceSym);
eqR  :=  eqMat.AddEqRow(true);;
_EqRow(eqR);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
eqR  :=  eqMat.AddEqRow(false);;
_EqRow(eqR);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqDollarChar (eqRow:TIPEqRow);begin
Expect(dollar_Sym);
eqRow.AddChild(TIPEqText.Create(LexString));;
end;

procedure TIPEqParser._EqPlainText (eqRow:TIPEqRow);var  eq:TIPEqPlainText;
begin
eq  :=  TIPEqPlainText.Create;
eqRow.AddChild(eq);
;
Expect(_atTSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqBold (eqRow:TIPEqRow);var  eq:TIPEqItalic;
begin
eq  :=  TIPEqItalic.Create;  eq.FontStyle  :=  fsBold;
eqRow.AddChild(eq);
;
Expect(_atBSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqItalic (eqRow:TIPEqRow);var  eq:TIPEqItalic;
begin
eq  :=  TIPEqItalic.Create;
eqRow.AddChild(eq);
;
Expect(_atISym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqBigger (eqRow:TIPEqRow);var  eq:TIPEqBigger;  opstr:String;
begin
eq  :=  TIPEqBigger.Create;
eqRow.AddChild(eq);
opstr  :=  '';
;
Expect(_atSIZESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
if (fCurrentInputSymbol = operator_Sym) OR
 (fCurrentInputSymbol = minus_Sym) then begin
if (fCurrentInputSymbol = operator_Sym) then begin
Get;
end else begin
Get;
end;
opstr  :=  LexString;;
end;
Expect(text_Sym);
eq.SetPointsFromString(opStr+LexString);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqCheck (eqRow:TIPEqRow);var  eq:TIPEqCheck;
begin
eq  :=  TIPEqCheck.Create;
eqRow.AddChild(eq);
;
Expect(_atCHECKSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_semicolonSym);
_EqCheckCol(eq);
Expect(_semicolonSym);
_EqCheckCol(eq);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqInput (eqRow:TIPEqRow);begin
Expect(_atINPUTSym);
Expect(_lbraceSym);
Expect(text_Sym);
eqRow.AddChild(TIPEqObject.Create(LexString));;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqHBraceB (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateHBraceB;
eqRow.AddChild(eq);
;
Expect(_atHBRACEBSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqHBraceT (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateHBraceT;
eqRow.AddChild(eq);
;
Expect(_atHBRACETSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqHBrace (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateHBrace;
eqRow.AddChild(eq);
;
Expect(_atHBRACESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqDBraceR (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateDBraceR;
eqRow.AddChild(eq);
;
Expect(_atDBRACERSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqDBraceL (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateDBraceL;
eqRow.AddChild(eq);
;
Expect(_atDBRACELSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqGrint (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateGrint;
eqRow.AddChild(eq);
;
Expect(_atGRINTSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqVectorR (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateVectorR;
eqRow.AddChild(eq);
;
Expect(_atVECTORRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqVectorL (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateVectorL;
eqRow.AddChild(eq);
;
Expect(_atVECTORLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqVector (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateVector;
eqRow.AddChild(eq);
;
Expect(_atVECTORSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqBraceR (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateBraceR;
eqRow.AddChild(eq);
;
Expect(_atBRACERSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqBraceL (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateBraceL;
eqRow.AddChild(eq);
;
Expect(_atBRACELSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqBrace (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateBrace;
eqRow.AddChild(eq);
;
Expect(_atBRACESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqParenR (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateParenR;
eqRow.AddChild(eq);
;
Expect(_atPARENRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqParenL (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateParenL;
eqRow.AddChild(eq);
;
Expect(_atPARENLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqParen (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateParen;
eqRow.AddChild(eq);
;
Expect(_atPARENSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqCBraceR (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateCBraceR;
eqRow.AddChild(eq);
;
Expect(_atCBRACERSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqCBraceL (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.CreateCBraceL;
eqRow.AddChild(eq);
;
Expect(_atCBRACELSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqCBrace (eqRow:TIPEqRow);var  eq:TIPEqCBrace;
begin
eq  :=  TIPEqCBrace.Create;
eqRow.AddChild(eq);
;
Expect(_atCBRACESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSum (eqRow:TIPEqRow);var  eq:TIPEqSum;
begin
eq  :=  TIPEqSum.Create;
eqRow.AddChild(eq);
;
Expect(_atSUMSym);
Expect(_lbraceSym);
eq.AddRow(TIPEqRow.Create);;
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
eq.AddRow(TIPEqRow.Create);;
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
eq.ReduceEmptyRows;
end;

procedure TIPEqParser._EqIntegral (eqRow:TIPEqRow);var  eq:TIPEqIntegral;
begin
eq  :=  TIPEqIntegral.Create;
eqRow.AddChild(eq);
;
Expect(_atINTEGRALSym);
Expect(_lbraceSym);
eq.AddRow(TIPEqRow.Create);;
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
eq.AddRow(TIPEqRow.Create);;
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
eq.ReduceEmptyRows;
end;

procedure TIPEqParser._EqTableR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,18);
eqRow.AddChild(eq);
;
Expect(_atTABLERSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTableL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,17);
eqRow.AddChild(eq);
;
Expect(_atTABLELSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTable (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,16);
eqRow.AddChild(eq);
;
Expect(_atTABLESym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTabR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,15);
eqRow.AddChild(eq);
;
Expect(_atTABRSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTabL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,14);
eqRow.AddChild(eq);
;
Expect(_atTABLSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTab (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,13);
eqRow.AddChild(eq);
;
Expect(_atTABSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqColumnR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,12);
eqRow.AddChild(eq);
;
Expect(_atCOLUMNRSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqColumnL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,11);
eqRow.AddChild(eq);
;
Expect(_atCOLUMNLSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqColumn (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,10);
eqRow.AddChild(eq);
;
Expect(_atCOLUMNSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRowR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,9);
eqRow.AddChild(eq);
;
Expect(_atROWRSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRowL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,8);
eqRow.AddChild(eq);
;
Expect(_atROWLSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRowC (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,7);
eqRow.AddChild(eq);
;
Expect(_atROWSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqAugmentR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,6);
eqRow.AddChild(eq);
;
Expect(_atAUGMENTRSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqAugmentL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,5);
eqRow.AddChild(eq);
;
Expect(_atAUGMENTLSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqAugment (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,4);
eqRow.AddChild(eq);
;
Expect(_atAUGMENTSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqMatR (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,3);
eqRow.AddChild(eq);
;
Expect(_atMATRSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqMatL (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,2);
eqRow.AddChild(eq);
;
Expect(_atMATLSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqMat (eqRow:TIPEqRow);var  eq:TIPEqMat;
begin
eq  :=  TIPEqMat.CreateN(0,0,1);
eqRow.AddChild(eq);
;
Expect(_atMATSym);
Expect(_lbraceSym);
_EqMatRow(eq);
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
_EqMatRow(eq);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRep (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateRep;
eqRow.AddChild(eq);
;
Expect(_atREPSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqPrime3 (eqRow:TIPEqRow);var  eq:TIPEqPrime;
begin
eq  :=  TIPEqPrime.CreatePrime3;
eqRow.AddChild(eq);
;
Expect(_atPRIME_threeSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqPrime2 (eqRow:TIPEqRow);var  eq:TIPEqPrime;
begin
eq  :=  TIPEqPrime.CreatePrime2;
eqRow.AddChild(eq);
;
Expect(_atPRIME_twoSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqPrime (eqRow:TIPEqRow);var  eq:TIPEqPrime;
begin
eq  :=  TIPEqPrime.Create;
eqRow.AddChild(eq);
;
Expect(_atPRIMESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqUmlaut (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateUmlaut;
eqRow.AddChild(eq);
;
Expect(_atUMLAUTSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqAccent (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateAccent;
eqRow.AddChild(eq);
;
Expect(_atACCENTSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqTilde (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateTilde;
eqRow.AddChild(eq);
;
Expect(_atTILDESym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqHat (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateHat;
eqRow.AddChild(eq);
;
Expect(_atHATSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSlash (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateSlash;
eqRow.AddChild(eq);
;
Expect(_atSLASHSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqARC (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateArc;
eqRow.AddChild(eq);
;
Expect(_atARCSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqUndrBRC (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateUndrBRC;
eqRow.AddChild(eq);
;
Expect(_atUNDRBRCSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqOverBRC (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateOverBrc;
eqRow.AddChild(eq);
;
Expect(_atOVERBRCSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRayDB (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateRayDB;
eqRow.AddChild(eq);
;
Expect(_atRAYDBSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRayR (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateRayR;
eqRow.AddChild(eq);
;
Expect(_atRAYRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqRayL (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateRayL;
eqRow.AddChild(eq);
;
Expect(_atRAYLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqArrowDB (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateArrowDB;
eqRow.AddChild(eq);
;
Expect(_atARROWDBSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqArrowR (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateArrowR;
eqRow.AddChild(eq);
;
Expect(_atARROWRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqArrowL (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateArrowL;
eqRow.AddChild(eq);
;
Expect(_atARROWLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqUndbbar (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateUndb;
eqRow.AddChild(eq);
;
Expect(_atUNDBBARSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqOvdbbar (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateOvdb;
eqRow.AddChild(eq);
;
Expect(_atOVDBBARSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqUndrbar (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.CreateUN;
eqRow.AddChild(eq);
;
Expect(_atUNDRBARSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqOverbar (eqRow:TIPEqRow);var  eq:TIPEqBar;
begin
eq  :=  TIPEqBar.Create;
eqRow.AddChild(eq);
;
Expect(_atOVERBARSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSyndiv (eqRow:TIPEqRow);var  eq:TIPEqCIS;
begin
eq  :=  TIPEqCIS.CreateN;
eqRow.AddChild(eq);
;
Expect(_atSYNDIVSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqCIS (eqRow:TIPEqRow);var  eq:TIPEqCIS;
begin
eq  :=  TIPEqCIS.Create;
eqRow.AddChild(eq);
;
Expect(_atCISSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqNORMR (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.CreateDR;
eqRow.AddChild(eq);
;
Expect(_atNORMRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqNORML (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.CreateDL;
eqRow.AddChild(eq);
;
Expect(_atNORMLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqNORM (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.CreateN;
eqRow.AddChild(eq);
;
Expect(_atNORMSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqABSR (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.CreateABSR;
eqRow.AddChild(eq);
;
Expect(_atABSRSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqABSL (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.CreateABSL;
eqRow.AddChild(eq);
;
Expect(_atABSLSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqABS (eqRow:TIPEqRow);var  eq:TIPEqABS;
begin
eq  :=  TIPEqABS.Create;
eqRow.AddChild(eq);
;
Expect(_atABSSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqLDivQ (eqRow:TIPEqRow);var  eq:TIPEqLDiv;
begin
eq  :=  TIPEqLDiv.CreateN;
eqRow.AddChild(eq);
;
Expect(_atLDIVQSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
_Expect(_semicolonSym);
_EqRow(eq.Row[2]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqLDiv (eqRow:TIPEqRow);var  eq:TIPEqLDiv;
begin
eq  :=  TIPEqLDiv.Create;
eqRow.AddChild(eq);
;
Expect(_atLDIVSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqUnder (eqRow:TIPEqRow);var  eq:TIPEqOverUnder;
begin
eq  :=  TIPEqOverUnder.CreateUnder;
eqRow.AddChild(eq);
;
Expect(_atUNDERSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqOver (eqRow:TIPEqRow);var  eq:TIPEqOverUnder;
begin
eq  :=  TIPEqOverUnder.CreateOver;
eqRow.AddChild(eq);
;
Expect(_atOVERSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqOverUnder (eqRow:TIPEqRow);var  eq:TIPEqOverUnder;
begin
eq  :=  TIPEqOverUnder.Create;
eqRow.AddChild(eq);
;
if (fCurrentInputSymbol = _atOVERUNDERSym) then begin
Get;
end else if (fCurrentInputSymbol = _atOVERUNDRSym) then begin
Get;
end else begin SynError(109);
end;
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
_Expect(_semicolonSym);
_EqRow(eq.Row[2]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSupSub (eqRow:TIPEqRow);var  eq:TIPEqSupSub;
begin
eq  :=  TIPEqSupSub.Create;
eqRow.AddChild(eq);
;
Expect(_atSUPSUBSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
_Expect(_semicolonSym);
_EqRow(eq.Row[2]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqMixedNum (eqRow:TIPEqRow);var  eq:TIPEqDivide;
     eqMNum:TIPEqMNum;
     eqR  :  TIPEqRow;
begin
if  FEqDocument.Authoring  then
begin
   eqMNum  :=  TIPEqMNum.Create;
   eqRow.AddChild(eqMnum);
   eqR  :=  eqMNum.Row[0];
end
else
   eqR  :=  eqRow;
;
if (fCurrentInputSymbol = _atMNUMSym) then begin
Get;
end else if (fCurrentInputSymbol = _atMIXSym) then begin
Get;
end else begin SynError(110);
end;
Expect(_lbraceSym);
_EqRow(eqR);
Expect(_semicolonSym);
if  not  EqDocument.Authoring  then
begin
   eq  :=TIPEqDivide.Create;
   eqRow.AddChild(eq);
   eqR  :=  eq.Row[0];
end
else
   eqr  :=  eqMnum.Row[1];;
_EqRow(eqR);
Expect(_semicolonSym);
if  not  EqDocument.Authoring  then
   eqR  :=  eq.Row[1]
else
   eqR  :=  eqMnum.Row[2];
;
_EqRow(eqR);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqParenChar (eqRow:TIPEqRow);begin
if (fCurrentInputSymbol = paren_Sym) then begin
Get;
end else if (fCurrentInputSymbol = lparen_Sym) then begin
Get;
end else if (fCurrentInputSymbol = rparen_Sym) then begin
Get;
end else begin SynError(111);
end;
eqRow.AddChild(TIPEqParen.Create(LexString[1]));;
end;

procedure TIPEqParser._EqOperator (eqRow:TIPEqRow);var  opType  :  TIPEqOpType;
begin
if (fCurrentInputSymbol = operator_Sym) then begin
Get;
end else if (fCurrentInputSymbol = minus_Sym) then begin
Get;
end else begin SynError(112);
end;
if  GetEqOpType(LexString,opType)  then
eqRow.AddChild(TIPEqOp.Create(opType))
else
eqRow.AddChild(TIPEqText.Create(LexString));
;
end;

procedure TIPEqParser._EqNum4 (eqRow:TIPEqRow);var  str  :  String;
     minusflag  :  boolean;

begin
str  :=  '';  minusflag  :=  false;;
Expect(_atNEGPSym);
Expect(_lbraceSym);
if (fCurrentInputSymbol = minus_Sym) then begin
Get;
minusflag  :=  true;
end;
Expect(text_Sym);
str  :=  str  +  LexString;
while (fCurrentInputSymbol = operator_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
Expect(_rbraceSym);

  if  minusflag  then
  begin
    //This  is  minus  a  minus  so  no  parens
    eqRow.AddChild(TIPEqText.Create(Trim(str)));
  end
  else
  begin
    eqRow.AddChild(TIPEqParen.Create('('));
    eqRow.AddChild(TIPEqText.Create(Trim(str)));
    eqRow.AddChild(TIPEqParen.Create(')'));
  end;
;
end;

procedure TIPEqParser._EqNum3 (eqRow:TIPEqRow);var  str  :  String;
     minusflag  :  boolean;
     dollarflag  :  boolean;
     parenflag  :  boolean;

begin
str  :=  '';  minusflag  :=  false;  parenflag  :=  false;;
Expect(_atCURRSym);
Expect(_lbraceSym);
if (fCurrentInputSymbol = minus_Sym) then begin
Get;
minusflag  :=  true;
end;
if (fCurrentInputSymbol = lparen_Sym) then begin
Get;
Expect(text_Sym);
str  :=  str  +  LexString;
while (fCurrentInputSymbol = operator_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
Expect(rparen_Sym);
parenflag  :=  true;
end else if (fCurrentInputSymbol = text_Sym) then begin
Get;
str  :=  str  +  LexString;
while (fCurrentInputSymbol = operator_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
end else begin SynError(113);
end;
Expect(_rbraceSym);

  if  minusflag  then
    eqRow.AddChild(TIPEQOp.Create(eqoMinus));
  eqRow.AddChild(TIPEqText.Create(CurrencyChars[EqDocument.CurrencyType]));
  if  parenflag  then
    eqRow.AddChild(TIPEqParen.Create('('));
  eqRow.AddChild(TIPEqText.Create(Trim(str)));
  if  parenflag  then
    eqRow.AddChild(TIPEqParen.Create(')'));
;
end;

procedure TIPEqParser._EqNum2 (eqRow:TIPEqRow);var  str  :  String;
     minusflag  :  boolean;
     dollarflag  :  boolean;
     parenflag  :  boolean;
     dollarchar  :  String;

begin
str  :=  '';  minusflag  :=  false;  dollarflag  :=  false;  parenflag  :=  false;  dollarchar  :=  '';
Expect(_atCNUMSym);
Expect(_lbraceSym);
if (fCurrentInputSymbol = minus_Sym) then begin
Get;
minusflag  :=  true;
end;
if (fCurrentInputSymbol = dollar_Sym) then begin
Get;
dollarflag  :=  true;  dollarchar  :=  LexString;
end;
if (fCurrentInputSymbol = lparen_Sym) then begin
Get;
Expect(text_Sym);
str  :=  str  +  LexString;
while (fCurrentInputSymbol = operator_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
Expect(rparen_Sym);
parenflag  :=  true;
end else if (fCurrentInputSymbol = text_Sym) then begin
Get;
str  :=  str  +  LexString;
while (fCurrentInputSymbol = operator_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
end else begin SynError(114);
end;
Expect(_rbraceSym);

  if  minusflag  then
    eqRow.AddChild(TIPEQOp.Create(eqoMinus));
  if  dollarflag  then
    eqRow.AddChild(TIPEqText.Create(dollarchar));
  if  parenflag  then
    eqRow.AddChild(TIPEqParen.Create('('));
  eqRow.AddChild(TIPEqText.Create(GetCNumArg(str)));
  if  parenflag  then
    eqRow.AddChild(TIPEqParen.Create(')'));
;
end;

procedure TIPEqParser._EqNum1 (eqRow:TIPEqRow);var  str  :  String;
begin
str  :=  '';
Expect(NUM_lparenSym);
Expect(text_Sym);
str  :=  LexString;
while (fCurrentInputSymbol = minus_Sym) do begin
Get;
str  :=  str  +  LexString;
Expect(text_Sym);
str  :=  str  +  LexString;
end;
Expect(rparen_Sym);
eqRow.AddChild(TIPEqText.Create(GetNumArg(str)));
end;

procedure TIPEqParser._EqNum (eqRow:TIPEqRow);begin
Expect(_atNUMSym);
Expect(_lbraceSym);
_EqRow(eqRow);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqEntity (eqRow:TIPEqRow);var    symbolType  :  TIPEqSymbolType;
       pType  :  char;
        opType  :  TIPEqOpType;

begin
Expect(enttext_Sym);
if  GetEqOpType(LexString,opType)  then
   eqRow.AddChild(TIPEqOp.Create(opType))
else  if  GetEqSymbolType(Copy(LexString,2,Length(LexString)-2),symbolType)  then
   eqRow.AddChild(TIPEqSymbolW.Create(SymbolType))
else  if  GetEqParenType(LexString,pType)  then
   eqRow.AddChild(TIPEqParen.Create(pType))
else  if  SameText(LexString,'&integral;')  then
   eqRow.AddChild(TIPEqIntegral.CreateSymbol)
else  if  SameText(LexString,'&contourintegral;')  then
   eqRow.AddChild(TIPEqIntegral.CreateContour)
else  if  SameText(LexString,'&sum;')  then
   eqRow.AddChild(TIPEqSum.CreateSymbol)
else
   eqRow.AddChild(TIPEqText.Create(LexString));
;
end;

procedure TIPEqParser._EqSub (eqRow:TIPEqRow);var  eq:TIPEqSubscript;
begin
eq  :=  TIPEqSubscript.Create;
eqRow.AddChild(eq);
;
if (fCurrentInputSymbol = _atSUBSym) then begin
Get;
end else if (fCurrentInputSymbol = _underscoreSym) then begin
Get;
end else begin SynError(115);
end;
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSuper (eqRow:TIPEqRow);var  eq:TIPEqSuperscript;
begin
eq  :=  TIPEqSuperscript.Create;
eqRow.AddChild(eq);
;
if (fCurrentInputSymbol = _atSUPSym) then begin
Get;
end else if (fCurrentInputSymbol = _uparrowSym) then begin
Get;
end else begin SynError(116);
end;
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqSqrt (eqRow:TIPEqRow);var  eq:TIPEqSqrt;
begin
eq  :=  TIPEqSqrt.Create;
eqRow.AddChild(eq);
;
Expect(_atRTSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
eq.AddRow(TIPEqRow.Create);;
_EqRow(eq.Row[1]);
end;
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqDivSM (eqRow:TIPEqRow);var  eq:TIPEqDivide;
begin
eq  :=  TIPEqDivide.CreateM;
eqRow.AddChild(eq);
;
Expect(_atDIVSMSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqDiv (eqRow:TIPEqRow);var  eq:TIPEqDivide;
begin
eq  :=  TIPEqDivide.Create;
eqRow.AddChild(eq);
;
Expect(_atDIVSym);
Expect(_lbraceSym);
_EqRow(eq.Row[0]);
_Expect(_semicolonSym);
_EqRow(eq.Row[1]);
Expect(_rbraceSym);
end;

procedure TIPEqParser._EqVAR(eqRow: TIPEqRow);
var
  eq:TIPEqVariable;
begin
  eq := TIPEqVariable.Create;
  eqRow.AddChild(eq);
  Expect(_atVARSym);
  Expect(_lbraceSym);
  _EqRow(eq.Row[0]);
  Expect(_rbraceSym);
end;

procedure TIPEqParser._EqText (eqRow:TIPEqRow);begin
if (fCurrentInputSymbol = text_Sym) then begin
Get;
eqRow.AddChild(TIPEqText.Create(LexString));;
end else if (fCurrentInputSymbol = literal_Sym) then begin
Get;
eqRow.AddChild(TIPEqChar.Create(LexString[2]));;
end else begin SynError(117);
end;
end;

procedure TIPEqParser._EqNode (eqRow:TIPEqRow);begin
case fCurrentInputSymbol of
  text_Sym, literal_Sym : begin
_EqText(eqRow);
    end;
  _atDIVSym : begin
_EqDiv(eqRow);
    end;
  _atDIVSMSym : begin
_EqDivSM(eqRow);
    end;
  _atRTSym : begin
_EqSqrt(eqRow);
    end;
  _atSUPSym, _uparrowSym : begin
_EqSuper(eqRow);
    end;
  _atSUBSym, _underscoreSym : begin
_EqSub(eqRow);
    end;
  enttext_Sym : begin
_EqEntity(eqRow);
    end;
  _atNUMSym : begin
_EqNum(eqRow);
    end;
  NUM_lparenSym : begin
_EqNum1(eqRow);
    end;
  _atCNUMSym : begin
_EqNum2(eqRow);
    end;
  _atCURRSym : begin
_EqNum3(eqRow);
    end;
  _atNEGPSym : begin
_EqNum4(eqRow);
    end;
  operator_Sym, minus_Sym : begin
_EqOperator(eqRow);
    end;
  paren_Sym, rparen_Sym, lparen_Sym : begin
_EqParenChar(eqRow);
    end;
  _atMNUMSym, _atMIXSym : begin
_EqMixedNum(eqRow);
    end;
  _atSUPSUBSym : begin
_EqSupSub(eqRow);
    end;
  _atOVERUNDERSym, _atOVERUNDRSym : begin
_EqOverUnder(eqRow);
    end;
  _atOVERSym : begin
_EqOver(eqRow);
    end;
  _atUNDERSym : begin
_EqUnder(eqRow);
    end;
  _atLDIVSym : begin
_EqLDiv(eqRow);
    end;
  _atLDIVQSym : begin
_EqLDivQ(eqRow);
    end;
  _atABSSym : begin
_EqABS(eqRow);
    end;
  _atABSLSym : begin
_EqABSL(eqRow);
    end;
  _atABSRSym : begin
_EqABSR(eqRow);
    end;
  _atNORMSym : begin
_EqNORM(eqRow);
    end;
  _atNORMLSym : begin
_EqNORML(eqRow);
    end;
  _atNORMRSym : begin
_EqNORMR(eqRow);
    end;
  _atVARSym : begin
_EqVAR(eqRow);
    end;
  _atCISSym : begin
_EqCIS(eqRow);
    end;
  _atSYNDIVSym : begin
_EqSyndiv(eqRow);
    end;
  _atOVERBARSym : begin
_EqOverbar(eqRow);
    end;
  _atUNDRBARSym : begin
_EqUndrbar(eqRow);
    end;
  _atOVDBBARSym : begin
_EqOvdbbar(eqRow);
    end;
  _atUNDBBARSym : begin
_EqUndbbar(eqRow);
    end;
  _atARROWLSym : begin
_EqArrowL(eqRow);
    end;
  _atARROWRSym : begin
_EqArrowR(eqRow);
    end;
  _atARROWDBSym : begin
_EqArrowDB(eqRow);
    end;
  _atRAYLSym : begin
_EqRayL(eqRow);
    end;
  _atRAYRSym : begin
_EqRayR(eqRow);
    end;
  _atRAYDBSym : begin
_EqRayDB(eqRow);
    end;
  _atOVERBRCSym : begin
_EqOverBRC(eqRow);
    end;
  _atUNDRBRCSym : begin
_EqUndrBRC(eqRow);
    end;
  _atARCSym : begin
_EqARC(eqRow);
    end;
  _atSLASHSym : begin
_EqSlash(eqRow);
    end;
  _atHATSym : begin
_EqHat(eqRow);
    end;
  _atTILDESym : begin
_EqTilde(eqRow);
    end;
  _atACCENTSym : begin
_EqAccent(eqRow);
    end;
  _atUMLAUTSym : begin
_EqUmlaut(eqRow);
    end;
  _atPRIMESym : begin
_EqPrime(eqRow);
    end;
  _atPRIME_twoSym : begin
_EqPrime2(eqRow);
    end;
  _atPRIME_threeSym : begin
_EqPrime3(eqRow);
    end;
  _atREPSym : begin
_EqRep(eqRow);
    end;
  _atMATSym : begin
_EqMat(eqRow);
    end;
  _atMATLSym : begin
_EqMatL(eqRow);
    end;
  _atMATRSym : begin
_EqMatR(eqRow);
    end;
  _atAUGMENTSym : begin
_EqAugment(eqRow);
    end;
  _atAUGMENTLSym : begin
_EqAugmentL(eqRow);
    end;
  _atAUGMENTRSym : begin
_EqAugmentR(eqRow);
    end;
  _atROWSym : begin
_EqRowC(eqRow);
    end;
  _atROWLSym : begin
_EqRowL(eqRow);
    end;
  _atROWRSym : begin
_EqRowR(eqRow);
    end;
  _atCOLUMNSym : begin
_EqColumn(eqRow);
    end;
  _atCOLUMNLSym : begin
_EqColumnL(eqRow);
    end;
  _atCOLUMNRSym : begin
_EqColumnR(eqRow);
    end;
  _atTABSym : begin
_EqTab(eqRow);
    end;
  _atTABLSym : begin
_EqTabL(eqRow);
    end;
  _atTABRSym : begin
_EqTabR(eqRow);
    end;
  _atTABLESym : begin
_EqTable(eqRow);
    end;
  _atTABLELSym : begin
_EqTableL(eqRow);
    end;
  _atTABLERSym : begin
_EqTableR(eqRow);
    end;
  _atINTEGRALSym : begin
_EqIntegral(eqRow);
    end;
  _atSUMSym : begin
_EqSum(eqRow);
    end;
  _atCBRACESym : begin
_EqCBrace(eqRow);
    end;
  _atCBRACELSym : begin
_EqCBraceL(eqRow);
    end;
  _atCBRACERSym : begin
_EqCBraceR(eqRow);
    end;
  _atPARENSym : begin
_EqParen(eqRow);
    end;
  _atPARENLSym : begin
_EqParenL(eqRow);
    end;
  _atPARENRSym : begin
_EqParenR(eqRow);
    end;
  _atBRACESym : begin
_EqBrace(eqRow);
    end;
  _atBRACELSym : begin
_EqBraceL(eqRow);
    end;
  _atBRACERSym : begin
_EqBraceR(eqRow);
    end;
  _atVECTORSym : begin
_EqVector(eqRow);
    end;
  _atVECTORLSym : begin
_EqVectorL(eqRow);
    end;
  _atVECTORRSym : begin
_EqVectorR(eqRow);
    end;
  _atGRINTSym : begin
_EqGrint(eqRow);
    end;
  _atDBRACELSym : begin
_EqDBraceL(eqRow);
    end;
  _atDBRACERSym : begin
_EqDBraceR(eqRow);
    end;
  _atHBRACESym : begin
_EqHBrace(eqRow);
    end;
  _atHBRACETSym : begin
_EqHBraceT(eqRow);
    end;
  _atHBRACEBSym : begin
_EqHBraceB(eqRow);
    end;
  _atINPUTSym : begin
_EqInput(eqRow);
    end;
  _atCHECKSym : begin
_EqCheck(eqRow);
    end;
  _atSIZESym : begin
_EqBigger(eqRow);
    end;
  _atISym : begin
_EqItalic(eqRow);
    end;
  _atBSym : begin
_EqBold(eqRow);
    end;
  _atTSym : begin
_EqPlainText(eqRow);
    end;
  dollar_Sym : begin
_EqDollarChar(eqRow);
    end;
  _lbraceSym : begin
Get;
_EqRow(eqRow);
Expect(_rbraceSym);
    end;
else begin SynError(118);
    end;
end;
end;

procedure TIPEqParser._EqRow (eqRow:TIPEqRow);begin
while _In(symSet[1], fCurrentInputSymbol) do begin
_EqNode(eqRow);
end;
end;

procedure TIPEqParser._IPEqParser;begin
Init;
_EqRow(FEqDocument);
if  fCurrentInputSymbol  <>  EOFSYMB  then
   SynError(200);
Final;
end;

function TIPEqParser.GetBuildDate : TDateTime;
const
  BDate = 39748;
  Hour = 10;
  Min = 07;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TIPEqParser.GetVersion : string;
begin
  Result := '0.0.0.163';
end;

function TIPEqParser.GetVersionStr : string;
begin
  Result := '0.0.0.163';
end;

function TIPEqParser.GetVersionInfo : string;
begin
  Result := 'Comment: ' + #13#10 +
'Author: ' + #13#10 +
'Copyright: ';
end;

procedure TIPEqParser.SetVersion(const Value : string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TIPEqParser._Expect(n : integer);
begin
  if CurrentInputSymbol = n then
    Get;
end; {_Expect}

procedure TIPEqParser.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_IPEqParser;
end;  {Parse}

procedure TIPEqParser.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 0, 4] := [];
symSet[ 0, 5] := [];
symSet[ 0, 6] := [];
symSet[ 1, 0] := [text_Sym, enttext_Sym, literal_Sym, operator_Sym, 
                    minus_Sym, dollar_Sym, paren_Sym, rparen_Sym, lparen_Sym, 
                    _lbraceSym, _atINPUTSym, _atDIVSym, _atDIVSMSym];
symSet[ 1, 1] := [_atSUPSUBSym-16, _atOVERUNDERSym-16, _atOVERUNDRSym-16, 
                    _atOVERSym-16, _atUNDERSym-16, _atLDIVSym-16, 
                    _atLDIVQSym-16, _atCBRACESym-16, _atCBRACELSym-16, 
                    _atCBRACERSym-16, _atPARENSym-16, _atPARENLSym-16, 
                    _atPARENRSym-16, _atBRACESym-16, _atBRACELSym-16, 
                    _atBRACERSym-16];
symSet[ 1, 2] := [_atVECTORSym-32, _atVECTORLSym-32, _atVECTORRSym-32, 
                    _atGRINTSym-32, _atDBRACELSym-32, _atDBRACERSym-32, 
                    _atHBRACESym-32, _atHBRACETSym-32, _atHBRACEBSym-32, 
                    _atABSSym-32, _atABSLSym-32, _atABSRSym-32, _atNORMSym-32, 
                    _atNORMLSym-32, _atNORMRSym-32, _atCISSym-32];
symSet[ 1, 3] := [_atSIZESym-48, _atSYNDIVSym-48, _atOVERBARSym-48, 
                    _atUNDRBARSym-48, _atOVDBBARSym-48, _atUNDBBARSym-48, 
                    _atARROWLSym-48, _atARROWRSym-48, _atARROWDBSym-48, 
                    _atRAYLSym-48, _atRAYRSym-48, _atRAYDBSym-48, 
                    _atOVERBRCSym-48, _atUNDRBRCSym-48, _atARCSym-48, 
                    _atSLASHSym-48];
symSet[ 1, 4] := [_atHATSym-64, _atTILDESym-64, _atACCENTSym-64, 
                    _atUMLAUTSym-64, _atPRIMESym-64, _atPRIME_twoSym-64, 
                    _atPRIME_threeSym-64, _atREPSym-64, _atMNUMSym-64, 
                    _atMIXSym-64, _atNUMSym-64, NUM_lparenSym-64, _atCNUMSym-64, 
                    _atCURRSym-64, _atNEGPSym-64, _atRTSym-64];
symSet[ 1, 5] := [_atSUPSym-80, _uparrowSym-80, _atSUBSym-80, 
                    _underscoreSym-80, _atMATSym-80, _atCHECKSym-80, 
                    _atMATLSym-80, _atMATRSym-80, _atAUGMENTSym-80, 
                    _atAUGMENTLSym-80, _atAUGMENTRSym-80, _atROWSym-80, 
                    _atROWLSym-80, _atROWRSym-80, _atCOLUMNSym-80, 
                    _atCOLUMNLSym-80];
symSet[ 1, 6] := [_atCOLUMNRSym-96, _atTABSym-96, _atTABLSym-96, 
                    _atTABRSym-96, _atTABLESym-96, _atTABLELSym-96, 
                    _atTABLERSym-96, _atINTEGRALSym-96, _atSUMSym-96, 
                    _atISym-96, _atBSym-96, _atTSym-96, _atVARSym-96];
end; {InitSymSet}

end { IPEqParser }.
