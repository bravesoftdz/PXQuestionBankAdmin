unit TDXExprParser;




{==============================================================================
TDXExprParser
0.0.0.400
Date of Generation: 9/28/2007 1:55 PM
Comment: 
Author: 
Copyright: 

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,TDXExpr,Variants,TDXExprFunction,TDXExprVariable,TDXExprSymbolicVar,Contnrs,TDXExprStringLiteral,TDXVar,Math,IPStrUtils,TDXExprSimEq,TDXExprObject,StrUtils,TDXExprModel,TDXExprMath,TDXExprReduce,mwStringHashList;



const
maxT = 125;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ETDXExprParser = class(Exception);
  TTDXExprParser = class;

  TTDXExprParserScanner = class(TCocoRScanner)
  private
    FOwner : TTDXExprParser;
fHashList: TmwStringHashList;
function CharInIgnoreSet(const Ch : char) : boolean;
procedure CheckLiteral(var Sym : integer);
function GetNextSymbolString: string;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TTDXExprParser read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TTDXExprParserScanner }

  TTDXExprParser = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..11] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : string;
    function GetVersionStr : string;
    procedure SetVersion(const Value : string);
    function GetVersionInfo : string;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _NegParenNumberLiteral (var ExprResult:TTDXExpr);
    procedure _CurrencyNumberLiteral (var ExprResult:TTDXExpr);
    procedure _CommaNumberLiteral1 (var ExprResult:TTDXExpr);
    procedure _CommaNumberLiteral (var ExprResult:TTDXExpr);
    procedure _IntegerLiteral (var value:TTDXExprValue);
    procedure _FloatLiteral (var value:TTDXExprValue);
    procedure _MixedNumber (var ExprResult:TTDXExpr);
    procedure _ExprVariable (var ExprResult:TTDXExpr);
    procedure _NumberLiteral (var ExprResult:TTDXExpr);
    procedure _BooleanLiteral (var value:TTDXExprValue);
    procedure _NumberLiteralVar (var ExprResult:TTDXExpr);
    procedure _StringLiteral (var value:TTDXExprValue);
    procedure _FunctionReduce (var ExprResult:TTDXExpr);
    procedure _FunctionMultArg (var ExprResult: TTDXExpr);
    procedure _FunctionFinancial (var ExprResult:TTDXExpr);
    procedure _FunctionSimEQ (var ExprResult:TTDXExpr);
    procedure _Function2Arg (var ftype:TTDXExprFunctionType);
    procedure _Function1Arg (var ftype:TTDXExprFunctionType);
    procedure _IfThenExpr (var ExprResult:TTDXExpr);
    procedure _FunctionTrigExpr (var ExprResult:TTDXExpr);
    procedure _FunctionLogExpr (var ExprResult:TTDXExpr);
    procedure _ModelExpr (var ExprResult: TTDXExpr);
    procedure _MathExpr (var ExprResult:TTDXExpr);
    procedure _FunctionParam (var ExprResult:TTDXExpr);
    procedure _ObjectExpr (var ExprResult: TTDXExpr);
    procedure _AbsEq (var ExprResult:TTDXExpr);
    procedure _NRootEq (var ExprResult:TTDXExpr);
    procedure _DivideEq (var ExprResult:TTDXExpr);
    procedure _SymbolicVariable (var ExprResult:TTDXExpr);
    procedure _Literal (var ExprResult:TTDXExpr);
    procedure _FactorNoParen (var ExprResult: TTDXExpr);
    procedure _ParenExpression (var ExprResult:TTDXExpr);
    procedure _Factor (var ExprResult:TTDXExpr);
    procedure _FunctionExpr (var ExprResult:TTDXExpr);
    procedure _SuperEq (var ExprResult:TTDXExpr);
    procedure _FactorFact (var ExprResult: TTDXExpr);
    procedure _FactorPower (var ExprResult: TTDXExpr);
    procedure _MulOp (var op:TTDXExprBinaryType; var special:String);
    procedure _FactorUnary (var ExprResult:TTDXExpr);
    procedure _Term (var ExprResult:TTDXExpr);
    procedure _AddOp (var op:TTDXExprBinaryType);
    procedure _TermFunc (var ExprResult:TTDXExpr);
    procedure _AbsExpression (var ExprResult:TTDXExpr);
    procedure _SimpleExpression (var ExprResult:TTDXExpr);
    procedure _ListExpression (var ExprResult:TTDXExpr);
    procedure _RelOp (var op:TTDXExprRelationalType);
    procedure _Expression (var ExprResult:TTDXExpr);
    procedure _BooleanExpression (var ExprResult:TTDXExpr);
    procedure _NotExpression (var ExprResult:TTDXExpr);
    procedure _AndExpression (var ExprResult:TTDXExpr);
    procedure _OrExpression (var ExprResult:TTDXExpr);
    procedure _TDXExprParser;

  private
    FRootNode : TTDXExpr;
    //FProblem : TTDXProblem;
    FNodeList : TObjectList;
    FOnSymVarCreate : TTDXSymVarCreateEvent;
    FOnSymVarGetValue: TTDXSymVarGetValueEvent;  
    FOnObjectGetValue: TTDXObjectGetValueEvent;
    FOnObjectCheckSyntax : TTDXObjectCheckSyntaxEvent;
    FTreatVarsAsSymbolic: boolean;  
    FIsMath : boolean;
    FForceAltTrigPowerForm : boolean;

    procedure Init;
    procedure Final;
    function AddNode(ANode:TTDXExpr):TTDXExpr;
    function PopNode(ANode:TTDXExpr):TTDXExpr;  
    function deQuote(const str:String):String;
    function MakeCommaVar(value:TTDXExprValue; dollar:boolean; parenneg:boolean):TTDXExprValue;
    function MakeCurrVar(value:TTDXExprValue; parenneg:boolean):TTDXExprValue;
    function MakeNegVar(value:TTDXExprValue):TTDXExprValue;

  
  protected
    FSymbolicSymbol : Integer;    
  
  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : string) : string; override;
    procedure Execute;
    function GetScanner : TTDXExprParserScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : string read GetVersionStr;
    property VersionInfo : string read GetVersionInfo;

  public
    procedure PreParse(var str:String);
    property RootNode : TTDXExpr read FRootNode write FRootNode;
    //property Problem:TTDXProblem read FProblem write FProblem;
    property OnSymVarCreate:TTDXSymVarCreateEvent read FOnSymVarCreate write FOnSymVarCreate;
    property OnSymVarGetValue:TTDXSymVarGetValueEvent read FOnSymVarGetValue write FOnSymVarGetValue;
    property OnObjectGetValue:TTDXObjectGetValueEvent read FOnObjectGetValue write FOnObjectGetValue;
    property OnObjectCheckSyntax:TTDXObjectCheckSyntaxEvent read FOnObjectCheckSyntax write FOnObjectCheckSyntax;
    property TreatVarsAsSymbolic:boolean read FTreatVarsAsSymbolic write FTreatVarsAsSymbolic;
    property IsMath:boolean read FIsMath write FIsMath;
    property ForceAltTrigPowerForm:boolean read FForceAltTrigPowerForm write FForceAltTrigPowerForm;


  
  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : string read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TTDXExprParser }

implementation



const

  EOFSYMB = 0;  integer_Sym = 1;  floatSym = 2;  dollar_Sym = 3;
  variableSym = 4;  symbolicSym = 5;  entitySym = 6;  object_Sym = 7;
  model_Sym = 8;  string_Sym = 9;  ORSym = 10;  ANDSym = 11;  NOTSym = 12;
  _equalSym = 13;  _lessSym = 14;  _greaterSym = 15;  _less_equalSym = 16;
  _greater_equalSym = 17;  _less_greaterSym = 18;  CONTAINSSym = 19;
  ONLYSym = 20;  _andLT_semicolonSym = 21;  _andGT_semicolonSym = 22;
  _andLE_semicolonSym = 23;  _andGE_semicolonSym = 24;
  _andNE_semicolonSym = 25;  _lbrackSym = 26;  _commaSym = 27;
  _semicolonSym = 28;  _rbrackSym = 29;  _barSym = 30;  _querySym = 31;
  _plusSym = 32;  _minusSym = 33;  _starSym = 34;  _slashSym = 35;
  _andTIMES_semicolonSym = 36;  _andDIV_semicolonSym = 37;  _uparrowSym = 38;
  _bangSym = 39;  _atSUP_lbraceSym = 40;  _rbraceSym = 41;
  _atRT_lbraceSym = 42;  _atABS_lbraceSym = 43;  _lparenSym = 44;
  _rparenSym = 45;  _atDIV_lbraceSym = 46;  _andLBRACKET_semicolonSym = 47;
  _andRBRACKET_semicolonSym = 48;  _andLBRACE_semicolonSym = 49;
  _andRBRACE_semicolonSym = 50;  PISym = 51;  _ESym = 52;
  _andPI_semicolonSym = 53;  _andEXP_semicolonSym = 54;
  _andINF_semicolonSym = 55;  MATHSym = 56;  MEVALSym = 57;  MINSym = 58;
  MAXSym = 59;  FILLARRAYSym = 60;  SUBARRAYSym = 61;  FRAC_twoMNUMSym = 62;
  SYMEQSym = 63;  REDUCESym = 64;  SINSym = 65;  COSSym = 66;  TANSym = 67;
  SECSym = 68;  CSCSym = 69;  COTSym = 70;  SINHSym = 71;  COSHSym = 72;
  TANHSym = 73;  SECHSym = 74;  CSCHSym = 75;  COTHSym = 76;  IFTHENSym = 77;
  LOGSym = 78;  _atSUBSym = 79;  _lbraceSym = 80;  ABSSym = 81;  ARCSINSym = 82;
  ARCCOSSym = 83;  ARCTANSym = 84;  ARCSINHSym = 85;  ARCCOSHSym = 86;
  ARCTANHSym = 87;  EXPSym = 88;  SQRTSym = 89;  LNSym = 90;  FLOORSym = 91;
  CEILSym = 92;  GCSSym = 93;  GCSRSym = 94;  ARCSECSym = 95;  ARCCSCSym = 96;
  ARCCOTSym = 97;  ARCSECHSym = 98;  ARCCSCHSym = 99;  ARCCOTHSym = 100;
  DIVSym = 101;  DIVXSym = 102;  GCFSym = 103;  LCMSym = 104;
  MIN_underscoreSym = 105;  MAX_underscoreSym = 106;  MODSym = 107;
  RTXSym = 108;  ROUNDSym = 109;  TRUNCSym = 110;  SIMPABSym = 111;
  SIMPBASym = 112;  LOGXSym = 113;  PERMSym = 114;  COMBSym = 115;
  EQCASESym = 116;  NEQCASESym = 117;  _atMNUM_lbraceSym = 118;  NUMSym = 119;
  _atCNUM_lbraceSym = 120;  _atCURR_lbraceSym = 121;  _atNEGP_lbraceSym = 122;
  TRUESym = 123;  FALSESym = 124;  NOSYMB = 125;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
procedure TTDXExprParser.Init;
begin
  fRootNode := nil;
end;

procedure TTDXExprParser.Final;
begin                   
  //Clean up in between parses just in case object stays around.
  FNodeList.Clear;
end;

function TTDXExprParser.AddNode(ANode:TTDXExpr):TTDXExpr;
begin
  FNodeList.Add(ANode);
  Result := ANode;
end;

function TTDXExprParser.PopNode(ANode:TTDXExpr):TTDXExpr;
begin
  if assigned(ANode) then
  begin
    FNodeList.Extract(ANode);
    Result := ANode;
  end
  else
    Result := nil;
end;  

function TTDXExprParser.deQuote(const str:String):String;
var
  p : PChar;
begin                          
  p := Pchar(str);
  Result := AnsiExtractQuotedStr(p,str[1]);
end;

function TTDXExprParser.MakeCommaVar(value:TTDXExprValue; dollar:boolean; parenneg:boolean ):TTDXExprValue;









var
  pPos : integer;
  fStr : String;          
  v : Double;
  text : String;
begin
  text := Trim(value);
  v := value;
  pPos := Pos('.',text);
  if pPos > 0 then
    fStr := ',.'+DupeString('#',Length(text)-pPos)
  else
    fStr := ',';        
  if parenneg then
    fStr := '(' + fStr + ')';
  if dollar then
    fStr := '$' + fStr;
  //if assigned(FPRoblem) then
  //  text := FProblem.FormatFloat(v,fstr)
  //else
    text := IPFormatFloat(v,fstr);










  Result := VarTDXCreate(v,text);
end;

function TTDXExprParser.MakeCurrVar(value:TTDXExprValue; parenneg:boolean ):TTDXExprValue;
var
  pPos : integer;
  fStr : String;          
  v : Double;
  text : String;
begin
  text := Trim(value);
  v := value;
  pPos := Pos('.',text);
  if pPos > 0 then
    fStr := '.'+DupeString('#',Length(text)-pPos)
  else
    fStr := '';        
  if parenneg then
    fStr := '(' + fStr + ')';
  fStr := '$' + fStr;
  //if assigned(FPRoblem) then
  //  text := FProblem.FormatFloat(v,fstr)
  //else
    text := IPFormatFloat(v,fstr);










  Result := VarTDXCreate(v,text);
end;

function TTDXExprParser.MakeNegVar(value:TTDXExprValue):TTDXExprValue;
var
  pPos : integer;
  fStr : String;          
  v : Double;
  text : String;
begin
  text := Trim(value);
  v := -value;
  pPos := Pos('.',text);
  if pPos > 0 then
    fStr := '.'+DupeString('#',Length(text)-pPos)
  else
    fStr := '';        
  fStr := '(' + fStr + ')';
  //if assigned(FPRoblem) then
  //  text := FProblem.FormatFloat(v,fstr)
  //else
    text := IPFormatFloat(v,fstr);










  Result := VarTDXCreate(v,text);
end;



  procedure TTDXExprParser.PreParse(var str:String);
  var
   i : Integer;
   n : Integer;
   foundAbs : Boolean;
   inSquote : Boolean;
   inDquote : Boolean;

  begin
    foundAbs := false;
    inSQuote := false;
    inDQuote := false;
    n := Length(str);
    for i := 1 to n do
    begin
      Case str[i] of
      '''': begin
              if not inDquote then
                inSquote := not inSquote;
            end;
      '"' : begin
              if not inSQUote then
                inDquote := not inDquote;
            end;
      '|' : begin
              if not (inSquote or inDquote) then
              begin
                foundAbs := not foundAbs;
                if not foundAbs then
                  str[i]:= '?';
              end;
            end;
      end;
    end;
  end;
  


(* End of Arbitrary Code *)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TTDXExprParserScanner ---- }

procedure TTDXExprParserScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}


function TTDXExprParserScanner.CharInIgnoreSet(const Ch : char) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= CHR(9)) AND (CurrInputCh <= CHR(13)));
end; {CharInIgnoreSet}

function TTDXExprParserScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    inc(q);
    inc(i);
  end;
end; {GetNextSymbolString}

procedure TTDXExprParserScanner.CheckLiteral(var Sym : integer);
var
  SymId : integer;
  DefaultSymId : integer;
  aToken : string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
      sym := SymId;
  end;
end; {CheckLiteral}


procedure TTDXExprParserScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while CharInIgnoreSet(CurrInputCh) do
  NextCh;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: begin
  BufferPosition := BufferPosition - ContextLen - 1;
  NextSymbol.Len := NextSymbol.Len - ContextLen;
  NextCh;
begin
sym := integer_Sym;
exit;
end;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := floatSym;
exit;
end;
   3: begin
sym := dollar_Sym;
exit;
end;
   4: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 5; 
end
else if (CurrInputCh = '[') then
begin
state := 9; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 6; 
end
else
begin
sym := variableSym;
exit;
end;
   6: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 8; 
end
else if (CurrInputCh = '~') then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 8; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else
begin
sym := variableSym;
exit;
end;
   9: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = ']') then
begin
state := 14; 
end
else if (CurrInputCh = '.') then
begin
state := 11; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 13; 
end
else if (CurrInputCh = '~') then
begin
state := 12; 
end
else
begin
  sym := _noSym;
exit;
end;
  12: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = ']') then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  14: begin
sym := variableSym;
exit;
end;
  15: begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  16: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = ';') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: begin
sym := entitySym;
CheckLiteral(sym);
exit;
end;
  19: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '@') then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  20: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  21: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 22; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  23: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 24; 
end
else
begin
  sym := _noSym;
exit;
end;
  24: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  25: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else
begin
sym := model_Sym;
exit;
end;
  26: if ((CurrInputCh = CHR(39))) then
begin
state := 30; 
end
else if ((CurrInputCh <= CHR(12)) OR
(CurrInputCh >= CHR(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(')) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  27: if ((CurrInputCh = '"')) then
begin
state := 31; 
end
else if ((CurrInputCh <= CHR(12)) OR
(CurrInputCh >= CHR(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#')) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  28: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 32;ContextLen := ContextLen + 1 
end
else
begin
sym := integer_Sym;
exit;
end;
  29: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 25; 
end
else
begin
sym := dollar_Sym;
exit;
end;
  30: if ((CurrInputCh = CHR(39))) then
begin
state := 26; 
end
else
begin
sym := string_Sym;
exit;
end;
  31: if ((CurrInputCh = '"')) then
begin
state := 27; 
end
else
begin
sym := string_Sym;
exit;
end;
  32: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 2;ContextLen := 0 
end
else if (CurrInputCh = '.') then
begin
state := 1;ContextLen := ContextLen + 1 
end
else
begin
sym := floatSym;
exit;
end;
  33: begin
sym := ORSym;
exit;
end;
  34: if (CurrInputCh = 'D') then
begin
state := 35; 
end
else
begin
  sym := _noSym;
exit;
end;
  35: begin
sym := ANDSym;
exit;
end;
  36: if (CurrInputCh = 'T') then
begin
state := 37; 
end
else
begin
  sym := _noSym;
exit;
end;
  37: begin
sym := NOTSym;
exit;
end;
  38: begin
sym := _equalSym;
exit;
end;
  39: if (CurrInputCh = '=') then
begin
state := 41; 
end
else if (CurrInputCh = '>') then
begin
state := 43; 
end
else
begin
sym := _lessSym;
exit;
end;
  40: if (CurrInputCh = '=') then
begin
state := 42; 
end
else
begin
sym := _greaterSym;
exit;
end;
  41: begin
sym := _less_equalSym;
exit;
end;
  42: begin
sym := _greater_equalSym;
exit;
end;
  43: begin
sym := _less_greaterSym;
exit;
end;
  44: if (CurrInputCh = 'T') then
begin
state := 45; 
end
else
begin
  sym := _noSym;
exit;
end;
  45: if (CurrInputCh = 'A') then
begin
state := 46; 
end
else
begin
  sym := _noSym;
exit;
end;
  46: if (CurrInputCh = 'I') then
begin
state := 47; 
end
else
begin
  sym := _noSym;
exit;
end;
  47: if (CurrInputCh = 'N') then
begin
state := 48; 
end
else
begin
  sym := _noSym;
exit;
end;
  48: if (CurrInputCh = 'S') then
begin
state := 49; 
end
else
begin
  sym := _noSym;
exit;
end;
  49: begin
sym := CONTAINSSym;
exit;
end;
  50: if (CurrInputCh = 'L') then
begin
state := 51; 
end
else
begin
  sym := _noSym;
exit;
end;
  51: if (CurrInputCh = 'Y') then
begin
state := 52; 
end
else
begin
  sym := _noSym;
exit;
end;
  52: begin
sym := ONLYSym;
exit;
end;
  53: begin
sym := _lbrackSym;
exit;
end;
  54: begin
sym := _commaSym;
exit;
end;
  55: begin
sym := _semicolonSym;
exit;
end;
  56: begin
sym := _rbrackSym;
exit;
end;
  57: begin
sym := _barSym;
exit;
end;
  58: begin
sym := _querySym;
exit;
end;
  59: begin
sym := _plusSym;
exit;
end;
  60: begin
sym := _minusSym;
exit;
end;
  61: begin
sym := _starSym;
exit;
end;
  62: begin
sym := _slashSym;
exit;
end;
  63: begin
sym := _uparrowSym;
exit;
end;
  64: begin
sym := _bangSym;
exit;
end;
  65: begin
sym := _atSUP_lbraceSym;
exit;
end;
  66: begin
sym := _rbraceSym;
exit;
end;
  67: begin
sym := _atRT_lbraceSym;
exit;
end;
  68: begin
sym := _atABS_lbraceSym;
exit;
end;
  69: begin
sym := _lparenSym;
exit;
end;
  70: begin
sym := _rparenSym;
exit;
end;
  71: begin
sym := _atDIV_lbraceSym;
exit;
end;
  72: begin
sym := PISym;
exit;
end;
  73: if (CurrInputCh = 'H') then
begin
state := 74; 
end
else
begin
  sym := _noSym;
exit;
end;
  74: begin
sym := MATHSym;
exit;
end;
  75: if (CurrInputCh = 'V') then
begin
state := 76; 
end
else
begin
  sym := _noSym;
exit;
end;
  76: if (CurrInputCh = 'A') then
begin
state := 77; 
end
else
begin
  sym := _noSym;
exit;
end;
  77: if (CurrInputCh = 'L') then
begin
state := 78; 
end
else
begin
  sym := _noSym;
exit;
end;
  78: begin
sym := MEVALSym;
exit;
end;
  79: if (CurrInputCh = 'L') then
begin
state := 80; 
end
else
begin
  sym := _noSym;
exit;
end;
  80: if (CurrInputCh = 'L') then
begin
state := 81; 
end
else
begin
  sym := _noSym;
exit;
end;
  81: if (CurrInputCh = 'A') then
begin
state := 82; 
end
else
begin
  sym := _noSym;
exit;
end;
  82: if (CurrInputCh = 'R') then
begin
state := 83; 
end
else
begin
  sym := _noSym;
exit;
end;
  83: if (CurrInputCh = 'R') then
begin
state := 84; 
end
else
begin
  sym := _noSym;
exit;
end;
  84: if (CurrInputCh = 'A') then
begin
state := 85; 
end
else
begin
  sym := _noSym;
exit;
end;
  85: if (CurrInputCh = 'Y') then
begin
state := 86; 
end
else
begin
  sym := _noSym;
exit;
end;
  86: begin
sym := FILLARRAYSym;
exit;
end;
  87: if (CurrInputCh = 'B') then
begin
state := 88; 
end
else
begin
  sym := _noSym;
exit;
end;
  88: if (CurrInputCh = 'A') then
begin
state := 89; 
end
else
begin
  sym := _noSym;
exit;
end;
  89: if (CurrInputCh = 'R') then
begin
state := 90; 
end
else
begin
  sym := _noSym;
exit;
end;
  90: if (CurrInputCh = 'R') then
begin
state := 91; 
end
else
begin
  sym := _noSym;
exit;
end;
  91: if (CurrInputCh = 'A') then
begin
state := 92; 
end
else
begin
  sym := _noSym;
exit;
end;
  92: if (CurrInputCh = 'Y') then
begin
state := 93; 
end
else
begin
  sym := _noSym;
exit;
end;
  93: begin
sym := SUBARRAYSym;
exit;
end;
  94: if (CurrInputCh = 'A') then
begin
state := 95; 
end
else
begin
  sym := _noSym;
exit;
end;
  95: if (CurrInputCh = 'C') then
begin
state := 96; 
end
else
begin
  sym := _noSym;
exit;
end;
  96: if (CurrInputCh = '2') then
begin
state := 97; 
end
else
begin
  sym := _noSym;
exit;
end;
  97: if (CurrInputCh = 'M') then
begin
state := 98; 
end
else
begin
  sym := _noSym;
exit;
end;
  98: if (CurrInputCh = 'N') then
begin
state := 99; 
end
else
begin
  sym := _noSym;
exit;
end;
  99: if (CurrInputCh = 'U') then
begin
state := 100; 
end
else
begin
  sym := _noSym;
exit;
end;
  100: if (CurrInputCh = 'M') then
begin
state := 101; 
end
else
begin
  sym := _noSym;
exit;
end;
  101: begin
sym := FRAC_twoMNUMSym;
exit;
end;
  102: if (CurrInputCh = 'M') then
begin
state := 103; 
end
else
begin
  sym := _noSym;
exit;
end;
  103: if (CurrInputCh = 'E') then
begin
state := 104; 
end
else
begin
  sym := _noSym;
exit;
end;
  104: if (CurrInputCh = 'Q') then
begin
state := 105; 
end
else
begin
  sym := _noSym;
exit;
end;
  105: begin
sym := SYMEQSym;
exit;
end;
  106: if (CurrInputCh = 'D') then
begin
state := 107; 
end
else
begin
  sym := _noSym;
exit;
end;
  107: if (CurrInputCh = 'U') then
begin
state := 108; 
end
else
begin
  sym := _noSym;
exit;
end;
  108: if (CurrInputCh = 'C') then
begin
state := 109; 
end
else
begin
  sym := _noSym;
exit;
end;
  109: if (CurrInputCh = 'E') then
begin
state := 110; 
end
else
begin
  sym := _noSym;
exit;
end;
  110: begin
sym := REDUCESym;
exit;
end;
  111: begin
sym := SINHSym;
exit;
end;
  112: begin
sym := COSHSym;
exit;
end;
  113: begin
sym := TANHSym;
exit;
end;
  114: begin
sym := SECHSym;
exit;
end;
  115: begin
sym := CSCHSym;
exit;
end;
  116: begin
sym := COTHSym;
exit;
end;
  117: if (CurrInputCh = 'T') then
begin
state := 118; 
end
else
begin
  sym := _noSym;
exit;
end;
  118: if (CurrInputCh = 'H') then
begin
state := 119; 
end
else
begin
  sym := _noSym;
exit;
end;
  119: if (CurrInputCh = 'E') then
begin
state := 120; 
end
else
begin
  sym := _noSym;
exit;
end;
  120: if (CurrInputCh = 'N') then
begin
state := 121; 
end
else
begin
  sym := _noSym;
exit;
end;
  121: begin
sym := IFTHENSym;
exit;
end;
  122: begin
sym := _lbraceSym;
exit;
end;
  123: if (CurrInputCh = 'S') then
begin
state := 124; 
end
else
begin
  sym := _noSym;
exit;
end;
  124: begin
sym := ABSSym;
exit;
end;
  125: begin
sym := ARCSINHSym;
exit;
end;
  126: begin
sym := ARCCOSHSym;
exit;
end;
  127: begin
sym := ARCTANHSym;
exit;
end;
  128: if (CurrInputCh = 'P') then
begin
state := 129; 
end
else
begin
  sym := _noSym;
exit;
end;
  129: begin
sym := EXPSym;
exit;
end;
  130: if (CurrInputCh = 'R') then
begin
state := 131; 
end
else
begin
  sym := _noSym;
exit;
end;
  131: if (CurrInputCh = 'T') then
begin
state := 132; 
end
else
begin
  sym := _noSym;
exit;
end;
  132: begin
sym := SQRTSym;
exit;
end;
  133: begin
sym := LNSym;
exit;
end;
  134: if (CurrInputCh = 'O') then
begin
state := 135; 
end
else
begin
  sym := _noSym;
exit;
end;
  135: if (CurrInputCh = 'O') then
begin
state := 136; 
end
else
begin
  sym := _noSym;
exit;
end;
  136: if (CurrInputCh = 'R') then
begin
state := 137; 
end
else
begin
  sym := _noSym;
exit;
end;
  137: begin
sym := FLOORSym;
exit;
end;
  138: if (CurrInputCh = 'I') then
begin
state := 139; 
end
else
begin
  sym := _noSym;
exit;
end;
  139: if (CurrInputCh = 'L') then
begin
state := 140; 
end
else
begin
  sym := _noSym;
exit;
end;
  140: begin
sym := CEILSym;
exit;
end;
  141: begin
sym := GCSRSym;
exit;
end;
  142: begin
sym := ARCSECHSym;
exit;
end;
  143: begin
sym := ARCCSCHSym;
exit;
end;
  144: begin
sym := ARCCOTHSym;
exit;
end;
  145: begin
sym := DIVXSym;
exit;
end;
  146: begin
sym := GCFSym;
exit;
end;
  147: if (CurrInputCh = 'M') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  148: begin
sym := LCMSym;
exit;
end;
  149: begin
sym := MIN_underscoreSym;
exit;
end;
  150: begin
sym := MAX_underscoreSym;
exit;
end;
  151: if (CurrInputCh = 'D') then
begin
state := 152; 
end
else
begin
  sym := _noSym;
exit;
end;
  152: begin
sym := MODSym;
exit;
end;
  153: if (CurrInputCh = 'X') then
begin
state := 154; 
end
else
begin
  sym := _noSym;
exit;
end;
  154: begin
sym := RTXSym;
exit;
end;
  155: if (CurrInputCh = 'U') then
begin
state := 156; 
end
else
begin
  sym := _noSym;
exit;
end;
  156: if (CurrInputCh = 'N') then
begin
state := 157; 
end
else
begin
  sym := _noSym;
exit;
end;
  157: if (CurrInputCh = 'D') then
begin
state := 158; 
end
else
begin
  sym := _noSym;
exit;
end;
  158: begin
sym := ROUNDSym;
exit;
end;
  159: if (CurrInputCh = 'C') then
begin
state := 160; 
end
else
begin
  sym := _noSym;
exit;
end;
  160: begin
sym := TRUNCSym;
exit;
end;
  161: if (CurrInputCh = 'B') then
begin
state := 162; 
end
else
begin
  sym := _noSym;
exit;
end;
  162: begin
sym := SIMPABSym;
exit;
end;
  163: if (CurrInputCh = 'A') then
begin
state := 164; 
end
else
begin
  sym := _noSym;
exit;
end;
  164: begin
sym := SIMPBASym;
exit;
end;
  165: begin
sym := LOGXSym;
exit;
end;
  166: if (CurrInputCh = 'R') then
begin
state := 167; 
end
else
begin
  sym := _noSym;
exit;
end;
  167: if (CurrInputCh = 'M') then
begin
state := 168; 
end
else
begin
  sym := _noSym;
exit;
end;
  168: begin
sym := PERMSym;
exit;
end;
  169: if (CurrInputCh = 'B') then
begin
state := 170; 
end
else
begin
  sym := _noSym;
exit;
end;
  170: begin
sym := COMBSym;
exit;
end;
  171: if (CurrInputCh = 'C') then
begin
state := 172; 
end
else
begin
  sym := _noSym;
exit;
end;
  172: if (CurrInputCh = 'A') then
begin
state := 173; 
end
else
begin
  sym := _noSym;
exit;
end;
  173: if (CurrInputCh = 'S') then
begin
state := 174; 
end
else
begin
  sym := _noSym;
exit;
end;
  174: if (CurrInputCh = 'E') then
begin
state := 175; 
end
else
begin
  sym := _noSym;
exit;
end;
  175: begin
sym := EQCASESym;
exit;
end;
  176: if (CurrInputCh = 'Q') then
begin
state := 177; 
end
else
begin
  sym := _noSym;
exit;
end;
  177: if (CurrInputCh = 'C') then
begin
state := 178; 
end
else
begin
  sym := _noSym;
exit;
end;
  178: if (CurrInputCh = 'A') then
begin
state := 179; 
end
else
begin
  sym := _noSym;
exit;
end;
  179: if (CurrInputCh = 'S') then
begin
state := 180; 
end
else
begin
  sym := _noSym;
exit;
end;
  180: if (CurrInputCh = 'E') then
begin
state := 181; 
end
else
begin
  sym := _noSym;
exit;
end;
  181: begin
sym := NEQCASESym;
exit;
end;
  182: begin
sym := _atMNUM_lbraceSym;
exit;
end;
  183: if (CurrInputCh = 'M') then
begin
state := 184; 
end
else
begin
  sym := _noSym;
exit;
end;
  184: begin
sym := NUMSym;
exit;
end;
  185: begin
sym := _atCNUM_lbraceSym;
exit;
end;
  186: begin
sym := _atCURR_lbraceSym;
exit;
end;
  187: begin
sym := _atNEGP_lbraceSym;
exit;
end;
  188: begin
sym := TRUESym;
exit;
end;
  189: if (CurrInputCh = 'L') then
begin
state := 190; 
end
else
begin
  sym := _noSym;
exit;
end;
  190: if (CurrInputCh = 'S') then
begin
state := 191; 
end
else
begin
  sym := _noSym;
exit;
end;
  191: if (CurrInputCh = 'E') then
begin
state := 192; 
end
else
begin
  sym := _noSym;
exit;
end;
  192: begin
sym := FALSESym;
exit;
end;
  193: if ((CurrInputCh = 'B') OR
(CurrInputCh >= 'E') AND (CurrInputCh <= 'L') OR
(CurrInputCh >= 'O') AND (CurrInputCh <= 'Q') OR
(CurrInputCh >= 'T') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '@') then
begin
state := 19; 
end
else if (CurrInputCh = 'S') then
begin
state := 209; 
end
else if (CurrInputCh = 'R') then
begin
state := 210; 
end
else if (CurrInputCh = 'A') then
begin
state := 211; 
end
else if (CurrInputCh = 'D') then
begin
state := 212; 
end
else if (CurrInputCh = 'M') then
begin
state := 213; 
end
else if (CurrInputCh = 'C') then
begin
state := 214; 
end
else if (CurrInputCh = 'N') then
begin
state := 215; 
end
else
begin
  sym := _noSym;
exit;
end;
  194: if (CurrInputCh = 'R') then
begin
state := 33; 
end
else if (CurrInputCh = 'N') then
begin
state := 50; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  195: if (CurrInputCh = 'N') then
begin
state := 34; 
end
else if (CurrInputCh = 'B') then
begin
state := 123; 
end
else if (CurrInputCh = 'R') then
begin
state := 216; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  196: if (CurrInputCh = 'O') then
begin
state := 36; 
end
else if (CurrInputCh = 'E') then
begin
state := 176; 
end
else if (CurrInputCh = 'U') then
begin
state := 183; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  197: if (CurrInputCh = 'O') then
begin
state := 217; 
end
else if (CurrInputCh = 'S') then
begin
state := 218; 
end
else if (CurrInputCh = 'E') then
begin
state := 138; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  198: if (CurrInputCh = 'I') then
begin
state := 72; 
end
else if (CurrInputCh = 'E') then
begin
state := 166; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  199: if (CurrInputCh = 'A') then
begin
state := 219; 
end
else if (CurrInputCh = 'E') then
begin
state := 75; 
end
else if (CurrInputCh = 'I') then
begin
state := 220; 
end
else if (CurrInputCh = 'O') then
begin
state := 151; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  200: if (CurrInputCh = 'I') then
begin
state := 79; 
end
else if (CurrInputCh = 'R') then
begin
state := 94; 
end
else if (CurrInputCh = 'L') then
begin
state := 134; 
end
else if (CurrInputCh = 'A') then
begin
state := 189; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  201: if (CurrInputCh = 'U') then
begin
state := 87; 
end
else if (CurrInputCh = 'Y') then
begin
state := 102; 
end
else if (CurrInputCh = 'I') then
begin
state := 221; 
end
else if (CurrInputCh = 'E') then
begin
state := 222; 
end
else if (CurrInputCh = 'Q') then
begin
state := 130; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  202: if (CurrInputCh = 'E') then
begin
state := 106; 
end
else if (CurrInputCh = 'T') then
begin
state := 153; 
end
else if (CurrInputCh = 'O') then
begin
state := 155; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  203: if (CurrInputCh = 'A') then
begin
state := 223; 
end
else if (CurrInputCh = 'R') then
begin
state := 224; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  204: if (CurrInputCh = 'F') then
begin
state := 117; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  205: if (CurrInputCh = 'O') then
begin
state := 225; 
end
else if (CurrInputCh = 'N') then
begin
state := 133; 
end
else if (CurrInputCh = 'C') then
begin
state := 147; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  206: if (CurrInputCh = 'X') then
begin
state := 128; 
end
else if (CurrInputCh = 'Q') then
begin
state := 171; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  207: if (CurrInputCh = 'C') then
begin
state := 226; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  208: if (CurrInputCh = 'I') then
begin
state := 227; 
end
else
begin
sym := symbolicSym;
CheckLiteral(sym);
exit;
end;
  209: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'T') OR
(CurrInputCh >= 'V') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'U') then
begin
state := 228; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  210: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'S') OR
(CurrInputCh >= 'U') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'T') then
begin
state := 229; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  211: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh = 'A') OR
(CurrInputCh >= 'C') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'B') then
begin
state := 230; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  212: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'H') OR
(CurrInputCh >= 'J') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'I') then
begin
state := 231; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  213: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'M') OR
(CurrInputCh >= 'O') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'N') then
begin
state := 232; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  214: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'M') OR
(CurrInputCh >= 'O') AND (CurrInputCh <= 'T') OR
(CurrInputCh >= 'V') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'N') then
begin
state := 233; 
end
else if (CurrInputCh = 'U') then
begin
state := 234; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  215: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'D') OR
(CurrInputCh >= 'F') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'E') then
begin
state := 235; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  216: if (CurrInputCh = 'C') then
begin
state := 236; 
end
else
begin
  sym := _noSym;
exit;
end;
  217: if (CurrInputCh = 'N') then
begin
state := 44; 
end
else if (CurrInputCh = 'S') then
begin
state := 237; 
end
else if (CurrInputCh = 'T') then
begin
state := 238; 
end
else if (CurrInputCh = 'M') then
begin
state := 169; 
end
else
begin
  sym := _noSym;
exit;
end;
  218: if (CurrInputCh = 'C') then
begin
state := 239; 
end
else
begin
  sym := _noSym;
exit;
end;
  219: if (CurrInputCh = 'T') then
begin
state := 73; 
end
else if (CurrInputCh = 'X') then
begin
state := 240; 
end
else
begin
  sym := _noSym;
exit;
end;
  220: if (CurrInputCh = 'N') then
begin
state := 241; 
end
else
begin
  sym := _noSym;
exit;
end;
  221: if (CurrInputCh = 'N') then
begin
state := 242; 
end
else if (CurrInputCh = 'M') then
begin
state := 243; 
end
else
begin
  sym := _noSym;
exit;
end;
  222: if (CurrInputCh = 'C') then
begin
state := 244; 
end
else
begin
  sym := _noSym;
exit;
end;
  223: if (CurrInputCh = 'N') then
begin
state := 245; 
end
else
begin
  sym := _noSym;
exit;
end;
  224: if (CurrInputCh = 'U') then
begin
state := 246; 
end
else
begin
  sym := _noSym;
exit;
end;
  225: if (CurrInputCh = 'G') then
begin
state := 247; 
end
else
begin
  sym := _noSym;
exit;
end;
  226: if (CurrInputCh = 'S') then
begin
state := 248; 
end
else if (CurrInputCh = 'F') then
begin
state := 146; 
end
else
begin
  sym := _noSym;
exit;
end;
  227: if (CurrInputCh = 'V') then
begin
state := 249; 
end
else
begin
  sym := _noSym;
exit;
end;
  228: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'O') OR
(CurrInputCh >= 'Q') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'P') then
begin
state := 250; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  229: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 67; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  230: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'R') OR
(CurrInputCh >= 'T') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'S') then
begin
state := 251; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  231: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'U') OR
(CurrInputCh >= 'W') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'V') then
begin
state := 252; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  232: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'T') OR
(CurrInputCh >= 'V') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'U') then
begin
state := 253; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  233: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'T') OR
(CurrInputCh >= 'V') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'U') then
begin
state := 254; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  234: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Q') OR
(CurrInputCh >= 'S') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'R') then
begin
state := 255; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  235: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'H') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'G') then
begin
state := 256; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  236: if (CurrInputCh = 'S') then
begin
state := 257; 
end
else if (CurrInputCh = 'C') then
begin
state := 258; 
end
else if (CurrInputCh = 'T') then
begin
state := 259; 
end
else
begin
  sym := _noSym;
exit;
end;
  237: if (CurrInputCh = 'H') then
begin
state := 112; 
end
else
begin
sym := COSSym;
exit;
end;
  238: if (CurrInputCh = 'H') then
begin
state := 116; 
end
else
begin
sym := COTSym;
exit;
end;
  239: if (CurrInputCh = 'H') then
begin
state := 115; 
end
else
begin
sym := CSCSym;
exit;
end;
  240: if (CurrInputCh = '_') then
begin
state := 150; 
end
else
begin
sym := MAXSym;
exit;
end;
  241: if (CurrInputCh = '_') then
begin
state := 149; 
end
else
begin
sym := MINSym;
exit;
end;
  242: if (CurrInputCh = 'H') then
begin
state := 111; 
end
else
begin
sym := SINSym;
exit;
end;
  243: if (CurrInputCh = 'P') then
begin
state := 260; 
end
else
begin
  sym := _noSym;
exit;
end;
  244: if (CurrInputCh = 'H') then
begin
state := 114; 
end
else
begin
sym := SECSym;
exit;
end;
  245: if (CurrInputCh = 'H') then
begin
state := 113; 
end
else
begin
sym := TANSym;
exit;
end;
  246: if (CurrInputCh = 'N') then
begin
state := 159; 
end
else if (CurrInputCh = 'E') then
begin
state := 188; 
end
else
begin
  sym := _noSym;
exit;
end;
  247: if (CurrInputCh = 'X') then
begin
state := 165; 
end
else
begin
sym := LOGSym;
exit;
end;
  248: if (CurrInputCh = 'R') then
begin
state := 141; 
end
else
begin
sym := GCSSym;
exit;
end;
  249: if (CurrInputCh = 'X') then
begin
state := 145; 
end
else
begin
sym := DIVSym;
exit;
end;
  250: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 65; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  251: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 68; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  252: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 71; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  253: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'L') OR
(CurrInputCh >= 'N') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'M') then
begin
state := 261; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  254: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'L') OR
(CurrInputCh >= 'N') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'M') then
begin
state := 262; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  255: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Q') OR
(CurrInputCh >= 'S') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'R') then
begin
state := 263; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  256: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'O') OR
(CurrInputCh >= 'Q') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = 'P') then
begin
state := 264; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  257: if (CurrInputCh = 'I') then
begin
state := 265; 
end
else if (CurrInputCh = 'E') then
begin
state := 266; 
end
else
begin
  sym := _noSym;
exit;
end;
  258: if (CurrInputCh = 'O') then
begin
state := 267; 
end
else if (CurrInputCh = 'S') then
begin
state := 268; 
end
else
begin
  sym := _noSym;
exit;
end;
  259: if (CurrInputCh = 'A') then
begin
state := 269; 
end
else
begin
  sym := _noSym;
exit;
end;
  260: if (CurrInputCh = 'A') then
begin
state := 161; 
end
else if (CurrInputCh = 'B') then
begin
state := 163; 
end
else
begin
  sym := _noSym;
exit;
end;
  261: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 182; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  262: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 185; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  263: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 186; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  264: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
state := 20; 
end
else if (CurrInputCh = '.') then
begin
state := 21; 
end
else if (CurrInputCh = ':') then
begin
state := 23; 
end
else if (CurrInputCh = '{') then
begin
state := 187; 
end
else
begin
sym := object_Sym;
CheckLiteral(sym);
exit;
end;
  265: if (CurrInputCh = 'N') then
begin
state := 270; 
end
else
begin
  sym := _noSym;
exit;
end;
  266: if (CurrInputCh = 'C') then
begin
state := 271; 
end
else
begin
  sym := _noSym;
exit;
end;
  267: if (CurrInputCh = 'S') then
begin
state := 272; 
end
else if (CurrInputCh = 'T') then
begin
state := 273; 
end
else
begin
  sym := _noSym;
exit;
end;
  268: if (CurrInputCh = 'C') then
begin
state := 274; 
end
else
begin
  sym := _noSym;
exit;
end;
  269: if (CurrInputCh = 'N') then
begin
state := 275; 
end
else
begin
  sym := _noSym;
exit;
end;
  270: if (CurrInputCh = 'H') then
begin
state := 125; 
end
else
begin
sym := ARCSINSym;
exit;
end;
  271: if (CurrInputCh = 'H') then
begin
state := 142; 
end
else
begin
sym := ARCSECSym;
exit;
end;
  272: if (CurrInputCh = 'H') then
begin
state := 126; 
end
else
begin
sym := ARCCOSSym;
exit;
end;
  273: if (CurrInputCh = 'H') then
begin
state := 144; 
end
else
begin
sym := ARCCOTSym;
exit;
end;
  274: if (CurrInputCh = 'H') then
begin
state := 143; 
end
else
begin
sym := ARCCSCSym;
exit;
end;
  275: if (CurrInputCh = 'H') then
begin
state := 127; 
end
else
begin
sym := ARCTANSym;
exit;
end;
  276: begin
sym := EOFSYMB;
CurrInputCh := #0;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TTDXExprParserScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(ITinyHash, HashSecondaryOne, SameText);
fHashList.AddString('&DIV;', _andDIV_semicolonSym, _andDIV_semicolonSym);
fHashList.AddString('&EXP;', _andEXP_semicolonSym, _andEXP_semicolonSym);
fHashList.AddString('&GE;', _andGE_semicolonSym, _andGE_semicolonSym);
fHashList.AddString('&GT;', _andGT_semicolonSym, _andGT_semicolonSym);
fHashList.AddString('&INF;', _andINF_semicolonSym, _andINF_semicolonSym);
fHashList.AddString('&LBRACE;', _andLBRACE_semicolonSym, _andLBRACE_semicolonSym);
fHashList.AddString('&LBRACKET;', _andLBRACKET_semicolonSym, _andLBRACKET_semicolonSym);
fHashList.AddString('&LE;', _andLE_semicolonSym, _andLE_semicolonSym);
fHashList.AddString('&LT;', _andLT_semicolonSym, _andLT_semicolonSym);
fHashList.AddString('&NE;', _andNE_semicolonSym, _andNE_semicolonSym);
fHashList.AddString('&PI;', _andPI_semicolonSym, _andPI_semicolonSym);
fHashList.AddString('&RBRACE;', _andRBRACE_semicolonSym, _andRBRACE_semicolonSym);
fHashList.AddString('&RBRACKET;', _andRBRACKET_semicolonSym, _andRBRACKET_semicolonSym);
fHashList.AddString('&TIMES;', _andTIMES_semicolonSym, _andTIMES_semicolonSym);
fHashList.AddString('@SUB', _atSUBSym, _atSUBSym);
fHashList.AddString('E', _ESym, _ESym);
CurrentCh := CapChAt;
fStartState[  0] := 276; fStartState[  1] := 277; fStartState[  2] := 277; fStartState[  3] := 277; 
fStartState[  4] := 277; fStartState[  5] := 277; fStartState[  6] := 277; fStartState[  7] := 277; 
fStartState[  8] := 277; fStartState[  9] := 277; fStartState[ 10] := 277; fStartState[ 11] := 277; 
fStartState[ 12] := 277; fStartState[ 13] := 277; fStartState[ 14] := 277; fStartState[ 15] := 277; 
fStartState[ 16] := 277; fStartState[ 17] := 277; fStartState[ 18] := 277; fStartState[ 19] := 277; 
fStartState[ 20] := 277; fStartState[ 21] := 277; fStartState[ 22] := 277; fStartState[ 23] := 277; 
fStartState[ 24] := 277; fStartState[ 25] := 277; fStartState[ 26] := 277; fStartState[ 27] := 277; 
fStartState[ 28] := 277; fStartState[ 29] := 277; fStartState[ 30] := 277; fStartState[ 31] := 277; 
fStartState[ 32] := 277; fStartState[ 33] := 64; fStartState[ 34] := 27; fStartState[ 35] := 277; 
fStartState[ 36] := 29; fStartState[ 37] := 277; fStartState[ 38] := 16; fStartState[ 39] := 26; 
fStartState[ 40] := 69; fStartState[ 41] := 70; fStartState[ 42] := 61; fStartState[ 43] := 59; 
fStartState[ 44] := 54; fStartState[ 45] := 60; fStartState[ 46] :=  2; fStartState[ 47] := 62; 
fStartState[ 48] := 28; fStartState[ 49] := 28; fStartState[ 50] := 28; fStartState[ 51] := 28; 
fStartState[ 52] := 28; fStartState[ 53] := 28; fStartState[ 54] := 28; fStartState[ 55] := 28; 
fStartState[ 56] := 28; fStartState[ 57] := 28; fStartState[ 58] := 277; fStartState[ 59] := 55; 
fStartState[ 60] := 39; fStartState[ 61] := 38; fStartState[ 62] := 40; fStartState[ 63] := 58; 
fStartState[ 64] := 193; fStartState[ 65] := 195; fStartState[ 66] := 15; fStartState[ 67] := 197; 
fStartState[ 68] := 208; fStartState[ 69] := 206; fStartState[ 70] := 200; fStartState[ 71] := 207; 
fStartState[ 72] := 15; fStartState[ 73] := 204; fStartState[ 74] := 15; fStartState[ 75] := 15; 
fStartState[ 76] := 205; fStartState[ 77] := 199; fStartState[ 78] := 196; fStartState[ 79] := 194; 
fStartState[ 80] := 198; fStartState[ 81] := 15; fStartState[ 82] := 202; fStartState[ 83] := 201; 
fStartState[ 84] := 203; fStartState[ 85] := 15; fStartState[ 86] := 15; fStartState[ 87] := 15; 
fStartState[ 88] := 15; fStartState[ 89] := 15; fStartState[ 90] := 15; fStartState[ 91] := 53; 
fStartState[ 92] := 277; fStartState[ 93] := 56; fStartState[ 94] := 63; fStartState[ 95] := 277; 
fStartState[ 96] := 277; fStartState[ 97] := 277; fStartState[ 98] := 277; fStartState[ 99] := 277; 
fStartState[100] := 277; fStartState[101] := 277; fStartState[102] := 277; fStartState[103] := 277; 
fStartState[104] := 277; fStartState[105] := 277; fStartState[106] := 277; fStartState[107] := 277; 
fStartState[108] := 277; fStartState[109] := 277; fStartState[110] := 277; fStartState[111] := 277; 
fStartState[112] := 277; fStartState[113] := 277; fStartState[114] := 277; fStartState[115] := 277; 
fStartState[116] := 277; fStartState[117] := 277; fStartState[118] := 277; fStartState[119] := 277; 
fStartState[120] := 277; fStartState[121] := 277; fStartState[122] := 277; fStartState[123] := 122; 
fStartState[124] := 57; fStartState[125] := 66; fStartState[126] :=  4; fStartState[127] := 277; 
fStartState[128] :=  3; fStartState[129] := 277; fStartState[130] := 277; fStartState[131] := 277; 
fStartState[132] := 277; fStartState[133] := 277; fStartState[134] := 277; fStartState[135] := 277; 
fStartState[136] := 277; fStartState[137] := 277; fStartState[138] := 277; fStartState[139] := 277; 
fStartState[140] := 277; fStartState[141] := 277; fStartState[142] := 277; fStartState[143] := 277; 
fStartState[144] := 277; fStartState[145] := 277; fStartState[146] := 277; fStartState[147] := 277; 
fStartState[148] := 277; fStartState[149] := 277; fStartState[150] := 277; fStartState[151] := 277; 
fStartState[152] := 277; fStartState[153] := 277; fStartState[154] := 277; fStartState[155] := 277; 
fStartState[156] := 277; fStartState[157] := 277; fStartState[158] := 277; fStartState[159] := 277; 
fStartState[160] := 277; fStartState[161] := 277; fStartState[162] := 277; fStartState[163] :=  3; 
fStartState[164] := 277; fStartState[165] :=  3; fStartState[166] := 277; fStartState[167] := 277; 
fStartState[168] := 277; fStartState[169] := 277; fStartState[170] := 277; fStartState[171] := 277; 
fStartState[172] := 277; fStartState[173] := 277; fStartState[174] := 277; fStartState[175] := 277; 
fStartState[176] := 277; fStartState[177] := 277; fStartState[178] := 277; fStartState[179] := 277; 
fStartState[180] := 277; fStartState[181] := 277; fStartState[182] := 277; fStartState[183] := 277; 
fStartState[184] := 277; fStartState[185] := 277; fStartState[186] := 277; fStartState[187] := 277; 
fStartState[188] := 277; fStartState[189] := 277; fStartState[190] := 277; fStartState[191] := 277; 
fStartState[192] := 277; fStartState[193] := 277; fStartState[194] := 277; fStartState[195] := 277; 
fStartState[196] := 277; fStartState[197] := 277; fStartState[198] := 277; fStartState[199] := 277; 
fStartState[200] := 277; fStartState[201] := 277; fStartState[202] := 277; fStartState[203] := 277; 
fStartState[204] := 277; fStartState[205] := 277; fStartState[206] := 277; fStartState[207] := 277; 
fStartState[208] := 277; fStartState[209] := 277; fStartState[210] := 277; fStartState[211] := 277; 
fStartState[212] := 277; fStartState[213] := 277; fStartState[214] := 277; fStartState[215] := 277; 
fStartState[216] := 277; fStartState[217] := 277; fStartState[218] := 277; fStartState[219] := 277; 
fStartState[220] := 277; fStartState[221] := 277; fStartState[222] := 277; fStartState[223] := 277; 
fStartState[224] := 277; fStartState[225] := 277; fStartState[226] := 277; fStartState[227] := 277; 
fStartState[228] := 277; fStartState[229] := 277; fStartState[230] := 277; fStartState[231] := 277; 
fStartState[232] := 277; fStartState[233] := 277; fStartState[234] := 277; fStartState[235] := 277; 
fStartState[236] := 277; fStartState[237] := 277; fStartState[238] := 277; fStartState[239] := 277; 
fStartState[240] := 277; fStartState[241] := 277; fStartState[242] := 277; fStartState[243] := 277; 
fStartState[244] := 277; fStartState[245] := 277; fStartState[246] := 277; fStartState[247] := 277; 
fStartState[248] := 277; fStartState[249] := 277; fStartState[250] := 277; fStartState[251] := 277; 
fStartState[252] := 277; fStartState[253] := 277; fStartState[254] := 277; fStartState[255] := 277; 
end; {Create}

destructor TTDXExprParserScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TTDXExprParser ---- }

constructor TTDXExprParser.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TTDXExprParserScanner.Create;
  GetScanner.Owner := self;
FRootNode := nil;
    FNodeList := TObjectList.Create;
    FSymbolicSymbol := SymbolicSym;
  
  InitSymSet;
end; {Create}

destructor TTDXExprParser.Destroy;
begin
  Scanner.Free;
FNodeList.Free;                                
  
  inherited;
end; {Destroy}

function TTDXExprParser.ErrorStr(const ErrorCode : integer; const Data : string) : string;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'integer_ expected';
   2 : Result := 'float expected';
   3 : Result := 'dollar_ expected';
   4 : Result := 'variable expected';
   5 : Result := 'symbolic expected';
   6 : Result := 'entity expected';
   7 : Result := 'object_ expected';
   8 : Result := 'model_ expected';
   9 : Result := 'string_ expected';
  10 : Result := '"OR" expected';
  11 : Result := '"AND" expected';
  12 : Result := '"NOT" expected';
  13 : Result := '"=" expected';
  14 : Result := '"<" expected';
  15 : Result := '">" expected';
  16 : Result := '"<=" expected';
  17 : Result := '">=" expected';
  18 : Result := '"<>" expected';
  19 : Result := '"CONTAINS" expected';
  20 : Result := '"ONLY" expected';
  21 : Result := '"&LT;" expected';
  22 : Result := '"&GT;" expected';
  23 : Result := '"&LE;" expected';
  24 : Result := '"&GE;" expected';
  25 : Result := '"&NE;" expected';
  26 : Result := '"[" expected';
  27 : Result := '"," expected';
  28 : Result := '";" expected';
  29 : Result := '"]" expected';
  30 : Result := '"|" expected';
  31 : Result := '"?" expected';
  32 : Result := '"+" expected';
  33 : Result := '"-" expected';
  34 : Result := '"*" expected';
  35 : Result := '"/" expected';
  36 : Result := '"&TIMES;" expected';
  37 : Result := '"&DIV;" expected';
  38 : Result := '"^" expected';
  39 : Result := '"!" expected';
  40 : Result := '"@SUP{" expected';
  41 : Result := '"}" expected';
  42 : Result := '"@RT{" expected';
  43 : Result := '"@ABS{" expected';
  44 : Result := '"(" expected';
  45 : Result := '")" expected';
  46 : Result := '"@DIV{" expected';
  47 : Result := '"&LBRACKET;" expected';
  48 : Result := '"&RBRACKET;" expected';
  49 : Result := '"&LBRACE;" expected';
  50 : Result := '"&RBRACE;" expected';
  51 : Result := '"PI" expected';
  52 : Result := '"E" expected';
  53 : Result := '"&PI;" expected';
  54 : Result := '"&EXP;" expected';
  55 : Result := '"&INF;" expected';
  56 : Result := '"MATH" expected';
  57 : Result := '"MEVAL" expected';
  58 : Result := '"MIN" expected';
  59 : Result := '"MAX" expected';
  60 : Result := '"FILLARRAY" expected';
  61 : Result := '"SUBARRAY" expected';
  62 : Result := '"FRAC2MNUM" expected';
  63 : Result := '"SYMEQ" expected';
  64 : Result := '"REDUCE" expected';
  65 : Result := '"SIN" expected';
  66 : Result := '"COS" expected';
  67 : Result := '"TAN" expected';
  68 : Result := '"SEC" expected';
  69 : Result := '"CSC" expected';
  70 : Result := '"COT" expected';
  71 : Result := '"SINH" expected';
  72 : Result := '"COSH" expected';
  73 : Result := '"TANH" expected';
  74 : Result := '"SECH" expected';
  75 : Result := '"CSCH" expected';
  76 : Result := '"COTH" expected';
  77 : Result := '"IFTHEN" expected';
  78 : Result := '"LOG" expected';
  79 : Result := '"@SUB" expected';
  80 : Result := '"{" expected';
  81 : Result := '"ABS" expected';
  82 : Result := '"ARCSIN" expected';
  83 : Result := '"ARCCOS" expected';
  84 : Result := '"ARCTAN" expected';
  85 : Result := '"ARCSINH" expected';
  86 : Result := '"ARCCOSH" expected';
  87 : Result := '"ARCTANH" expected';
  88 : Result := '"EXP" expected';
  89 : Result := '"SQRT" expected';
  90 : Result := '"LN" expected';
  91 : Result := '"FLOOR" expected';
  92 : Result := '"CEIL" expected';
  93 : Result := '"GCS" expected';
  94 : Result := '"GCSR" expected';
  95 : Result := '"ARCSEC" expected';
  96 : Result := '"ARCCSC" expected';
  97 : Result := '"ARCCOT" expected';
  98 : Result := '"ARCSECH" expected';
  99 : Result := '"ARCCSCH" expected';
 100 : Result := '"ARCCOTH" expected';
 101 : Result := '"DIV" expected';
 102 : Result := '"DIVX" expected';
 103 : Result := '"GCF" expected';
 104 : Result := '"LCM" expected';
 105 : Result := '"MIN_" expected';
 106 : Result := '"MAX_" expected';
 107 : Result := '"MOD" expected';
 108 : Result := '"RTX" expected';
 109 : Result := '"ROUND" expected';
 110 : Result := '"TRUNC" expected';
 111 : Result := '"SIMPAB" expected';
 112 : Result := '"SIMPBA" expected';
 113 : Result := '"LOGX" expected';
 114 : Result := '"PERM" expected';
 115 : Result := '"COMB" expected';
 116 : Result := '"EQCASE" expected';
 117 : Result := '"NEQCASE" expected';
 118 : Result := '"@MNUM{" expected';
 119 : Result := '"NUM" expected';
 120 : Result := '"@CNUM{" expected';
 121 : Result := '"@CURR{" expected';
 122 : Result := '"@NEGP{" expected';
 123 : Result := '"TRUE" expected';
 124 : Result := '"FALSE" expected';
 125 : Result := 'not expected';
 126 : Result := 'invalid NegParenNumberLiteral';
 127 : Result := 'invalid CurrencyNumberLiteral';
 128 : Result := 'invalid CurrencyNumberLiteral';
 129 : Result := 'invalid CommaNumberLiteral1';
 130 : Result := 'invalid CommaNumberLiteral1';
 131 : Result := 'invalid NumberLiteral';
 132 : Result := 'invalid BooleanLiteral';
 133 : Result := 'invalid NumberLiteralVar';
 134 : Result := 'invalid FunctionMultArg';
 135 : Result := 'invalid FunctionFinancial';
 136 : Result := 'invalid Function2Arg';
 137 : Result := 'invalid Function1Arg';
 138 : Result := 'invalid FunctionTrigExpr';
 139 : Result := 'invalid FunctionLogExpr';
 140 : Result := 'invalid MathExpr';
 141 : Result := 'invalid SymbolicVariable';
 142 : Result := 'invalid Literal';
 143 : Result := 'invalid FactorNoParen';
 144 : Result := 'invalid ParenExpression';
 145 : Result := 'invalid Factor';
 146 : Result := 'invalid FunctionExpr';
 147 : Result := 'invalid FactorPower';
 148 : Result := 'invalid MulOp';
 149 : Result := 'invalid AddOp';
 150 : Result := 'invalid RelOp';
 151 : Result := 'invalid Expression';

200 : Result := 'Text after end of valid expression';

  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TTDXExprParser.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TTDXExprParser.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TTDXExprParser.GetScanner : TTDXExprParserScanner;
begin
  Result := Scanner AS TTDXExprParserScanner;
end; {GetScanner}

function TTDXExprParser._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TTDXExprParser._NegParenNumberLiteral (var  ExprResult:TTDXExpr);var  value:TTDXExprValue;
     neg  :  boolean;
     dollarchar  :  string;



begin
neg  :=  false;  dollarchar  :=  '';
Expect(_atNEGP_lbraceSym);
if (fCurrentInputSymbol = _minusSym) then begin
Get;
neg  :=  true;;
end;
if (fCurrentInputSymbol = floatSym) then begin
_FloatLiteral(value);
end else if (fCurrentInputSymbol = integer_Sym) then begin
_IntegerLiteral(value);
end else begin SynError(126);
end;
Expect(_rbraceSym);

  if  neg  then
    value  :=  -value;
  ExprResult  :=  AddNode(TTDXExprLiteral.Create(MakeNegVar(value)));
end;

procedure TTDXExprParser._CurrencyNumberLiteral (var  ExprResult:TTDXExpr);var  value:TTDXExprValue;
     neg  :  boolean;
     dollar  :  boolean;
     parenneg  :  boolean;
     dollarchar  :  string;



begin
neg  :=  false;  dollar  :=  false;  parenneg  :=  false;  dollarchar  :=  '';
Expect(_atCURR_lbraceSym);
if (fCurrentInputSymbol = _minusSym) then begin
Get;
neg  :=  true;;
end;
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
if (fCurrentInputSymbol = floatSym) then begin
_FloatLiteral(value);
end else if (fCurrentInputSymbol = integer_Sym) then begin
_IntegerLiteral(value);
end else begin SynError(127);
end;
Expect(_rparenSym);
parenneg  :=  true;
end else if (fCurrentInputSymbol = integer_Sym) OR
 (fCurrentInputSymbol = floatSym) then begin
if (fCurrentInputSymbol = floatSym) then begin
_FloatLiteral(value);
end else begin
_IntegerLiteral(value);
end;
end else begin SynError(128);
end;
Expect(_rbraceSym);
if  neg  then
   value  :=  -value;
if  parenneg  then
   value  :=  -value;
ExprResult  :=  AddNode(TTDXExprLiteral.Create(MakeCurrVar(value,parenneg)));
end;

procedure TTDXExprParser._CommaNumberLiteral1 (var  ExprResult:TTDXExpr);var  value:TTDXExprValue;
     neg  :  boolean;
     dollar  :  boolean;
     parenneg  :  boolean;
     dollarchar  :  string;



begin
neg  :=  false;  dollar  :=  false;  parenneg  :=  false;  dollarchar  :=  '';
Expect(_atCNUM_lbraceSym);
if (fCurrentInputSymbol = _minusSym) then begin
Get;
neg  :=  true;;
end;
if (fCurrentInputSymbol = dollar_Sym) then begin
Get;
dollar  :=  true;  dollarchar  :=  LexString;;
end;
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
if (fCurrentInputSymbol = floatSym) then begin
_FloatLiteral(value);
end else if (fCurrentInputSymbol = integer_Sym) then begin
_IntegerLiteral(value);
end else begin SynError(129);
end;
Expect(_rparenSym);
parenneg  :=  true;
end else if (fCurrentInputSymbol = integer_Sym) OR
 (fCurrentInputSymbol = floatSym) then begin
if (fCurrentInputSymbol = floatSym) then begin
_FloatLiteral(value);
end else begin
_IntegerLiteral(value);
end;
end else begin SynError(130);
end;
Expect(_rbraceSym);
if  neg  then
   value  :=  -value;
if  parenneg  then
   value  :=  -value;
ExprResult  :=  AddNode(TTDXExprLiteral.Create(MakeCommaVar(value,dollar,parenneg)));
end;

procedure TTDXExprParser._CommaNumberLiteral (var  ExprResult:TTDXExpr);var  buf  :  String;
begin
Expect(NUMSym);
Expect(_lparenSym);
Expect(string_Sym);
buf  :=  Dequote(LexString);;
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprLiteral.Create(VarTDXCreate(IPStrToFloat(buf),buf)));
end;

procedure TTDXExprParser._IntegerLiteral (var  value:TTDXExprValue);begin
Expect(integer_Sym);
value  :=  VarTDXCreate(IPStrToFloat(LexString),LexString);
end;

procedure TTDXExprParser._FloatLiteral (var  value:TTDXExprValue);var  str  :  String;
begin
Expect(floatSym);
str  :=  LexString;
if  str[Length(str)]  =  '.'  then  Delete(str,Length(str),1);
value  :=  VarTDXCreate(IPStrToFloat(str),str);
end;

procedure TTDXExprParser._MixedNumber (var  ExprResult:TTDXExpr);var  expr1,expr2,expr3:TTDXExpr;
begin
Expect(_atMNUM_lbraceSym);
_NumberLiteralVar(Expr1);
Expect(_semicolonSym);
_NumberLiteralVar(Expr2);
Expect(_semicolonSym);
_NumberLiteralVar(Expr3);
Expect(_rbraceSym);
ExprResult  :=  AddNode(TTDXExprMixedNum.Create(PopNode(Expr1),PopNode(expr2),PopNode(expr3)));
end;

procedure TTDXExprParser._ExprVariable (var  ExprResult:TTDXExpr);var  v  :  TTDXExprVariable;
begin
Expect(variableSym);

if  FTreatVarsAsSymbolic  then
begin
  ExprResult  :=  AddNode(TTDXExprSymbolicVar.Create(Copy(LexString,2,Length(LexString)-1)));
  TTDXExprSymbolicVar(ExprResult).OnGetValue  :=  FOnSymVarGetValue;
  if  assigned(FOnSymVarCreate)  then
    FOnSymVarCreate(ExprResult,Copy(LexString,2,Length(LexString)-1));
end
else
begin
  v  :=  TTDXExprVariable.Create(Copy(LexString,2,Length(LexString)-1));
  v.IsMath  :=  FIsMath;
  ExprResult  :=  AddNode(v);
end;
;
end;

procedure TTDXExprParser._NumberLiteral (var  ExprResult:TTDXExpr);var  value:TTDXExprValue;
begin
case fCurrentInputSymbol of
  floatSym : begin
_FloatLiteral(value);
ExprResult  :=  AddNode(TTDXExprLiteral.Create(value));
    end;
  integer_Sym : begin
_IntegerLiteral(value);
ExprResult  :=  AddNode(TTDXExprLiteral.Create(value));
    end;
  NUMSym : begin
_CommaNumberLiteral(ExprResult);
    end;
  _atCNUM_lbraceSym : begin
_CommaNumberLiteral1(ExprResult);
    end;
  _atCURR_lbraceSym : begin
_CurrencyNumberLiteral(ExprResult);
    end;
  _atNEGP_lbraceSym : begin
_NegParenNumberLiteral(ExprResult);
    end;
else begin SynError(131);
    end;
end;
end;

procedure TTDXExprParser._BooleanLiteral (var  value:TTDXExprValue);begin
if (fCurrentInputSymbol = TRUESym) then begin
Get;
value  :=   True;
end else if (fCurrentInputSymbol = FALSESym) then begin
Get;
value  :=  False;
end else begin SynError(132);
end;
end;

procedure TTDXExprParser._NumberLiteralVar (var  ExprResult:TTDXExpr);begin
if _In(symSet[1], fCurrentInputSymbol) then begin
_NumberLiteral(ExprResult);
end else if (fCurrentInputSymbol = variableSym) then begin
_ExprVariable(ExprResult);
end else if (fCurrentInputSymbol = _atMNUM_lbraceSym) then begin
_MixedNumber(ExprResult);
end else begin SynError(133);
end;
end;

procedure TTDXExprParser._StringLiteral (var  value:TTDXExprValue);begin
Expect(string_Sym);
value  :=  VarAsType(Dequote(LexString),varString);
end;

procedure TTDXExprParser._FunctionReduce (var  ExprResult:TTDXExpr);var  expr1:TTDXExpr;  fmt:String;
begin
fmt  :=  '';;
Expect(REDUCESym);
Expect(_lparenSym);
_Expression(expr1);
if (fCurrentInputSymbol = _commaSym) then begin
Get;
Expect(string_Sym);
fmt  :=  Dequote(LexString);;
end;
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprReduce.Create(PopNode(expr1),fmt));
end;

procedure TTDXExprParser._FunctionMultArg (var  ExprResult:  TTDXExpr);var  expr  :TTDXExpr;  ftype:TTDXExprFunctionType;
begin
ftype  :=  tdxefMin;;
if (fCurrentInputSymbol = MINSym) then begin
Get;
ftype  :=  tdxefMin;;
end else if (fCurrentInputSymbol = MAXSym) then begin
Get;
ftype  :=  tdxefMax;;
end else begin SynError(134);
end;
Expect(_lparenSym);
_OrExpression(expr);
ExprResult  :=  AddNode(TTDXExprFunction.create(ftype,[]));
   (ExprResult  as  TTDXExprFunction).AddParam(PopNode(expr));;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_OrExpression(expr);
(ExprResult  as  TTDXExprFunction).AddParam(PopNode(expr));;
end;
Expect(_rparenSym);
end;

procedure TTDXExprParser._FunctionFinancial (var  ExprResult:TTDXExpr);var  expr1,expr2,expr3:TTDXExpr;  ftype:TTDXExprFunctionType;
begin
if (fCurrentInputSymbol = FILLARRAYSym) then begin
Get;
ftype  :=  tdxefFillArray;  expr3  :=  nil;;
Expect(_lparenSym);
_Expression(expr1);
Expect(_commaSym);
_Expression(expr2);
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_Expression(expr3);
end;
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprFunction.create(ftype,[PopNode(expr1),PopNode(expr2),PopNode(expr3)]));;
end else if (fCurrentInputSymbol = SUBARRAYSym) then begin
Get;
ftype  :=  tdxefSubArray;  expr3  :=  nil;;
Expect(_lparenSym);
_Expression(expr1);
Expect(_commaSym);
_Expression(expr2);
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_Expression(expr3);
end;
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprFunction.create(ftype,[PopNode(expr1),PopNode(expr2),PopNode(expr3)]));;
end else if (fCurrentInputSymbol = FRAC_twoMNUMSym) then begin
Get;
ftype  :=  tdxefFrac2Mnum;  expr3  :=  nil;;
Expect(_lparenSym);
_Expression(expr1);
Expect(_commaSym);
_Expression(expr2);
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_Expression(expr3);
end;
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprFunction.create(ftype,[PopNode(expr1),PopNode(expr2),PopNode(expr3)]));;
end else begin SynError(135);
end;
end;

procedure TTDXExprParser._FunctionSimEQ (var  ExprResult:TTDXExpr);var  expr1,expr2,expr3:TTDXExprValue;
begin
Expect(SYMEQSym);
Expect(_lparenSym);
_StringLiteral(expr1);
Expect(_commaSym);
_StringLiteral(expr2);
Expect(_commaSym);
_StringLiteral(expr3);
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprSimEq.Create(expr1,expr2,expr3));
end;

procedure TTDXExprParser._Function2Arg (var  ftype:TTDXExprFunctionType);begin
case fCurrentInputSymbol of
  DIVSym : begin
Get;
ftype  :=  tdxefDiv;
    end;
  DIVXSym : begin
Get;
ftype  :=  tdxefDivX;
    end;
  GCFSym : begin
Get;
ftype  :=  tdxefGCF;
    end;
  LCMSym : begin
Get;
ftype  :=  tdxefLCM;
    end;
  MIN_underscoreSym : begin
Get;
ftype  :=  tdxefMin;
    end;
  MAX_underscoreSym : begin
Get;
ftype  :=  tdxefMax;
    end;
  MODSym : begin
Get;
ftype  :=  tdxefMod;
    end;
  RTXSym : begin
Get;
ftype  :=  tdxefRTX;
    end;
  ROUNDSym : begin
Get;
ftype  :=  tdxefRound;
    end;
  TRUNCSym : begin
Get;
ftype  :=  tdxefTrunc;
    end;
  SIMPABSym : begin
Get;
ftype  :=  tdxefSimpAB;
    end;
  SIMPBASym : begin
Get;
ftype  :=  tdxefSimpBA;
    end;
  LOGXSym : begin
Get;
ftype  :=  tdxefLogX;
    end;
  PERMSym : begin
Get;
ftype  :=  tdxefPerm;
    end;
  COMBSym : begin
Get;
ftype  :=  tdxefComb;
    end;
  EQCASESym : begin
Get;
ftype  :=  tdxefEqCase;
    end;
  NEQCASESym : begin
Get;
ftype  :=  tdxefNeqCase;
    end;
else begin SynError(136);
    end;
end;
end;

procedure TTDXExprParser._Function1Arg (var  ftype:TTDXExprFunctionType);begin
case fCurrentInputSymbol of
  ABSSym : begin
Get;
ftype  :=  tdxefAbs;
    end;
  ARCSINSym : begin
Get;
ftype  :=  tdxefArcSin;
    end;
  ARCCOSSym : begin
Get;
ftype  :=  tdxefArcCos;
    end;
  ARCTANSym : begin
Get;
ftype  :=  tdxefArcTan;
    end;
  ARCSINHSym : begin
Get;
ftype  :=  tdxefArcSinh;
    end;
  ARCCOSHSym : begin
Get;
ftype  :=  tdxefArcCosh;
    end;
  ARCTANHSym : begin
Get;
ftype  :=  tdxefArcTanh;
    end;
  EXPSym : begin
Get;
ftype  :=  tdxefExp;
    end;
  SQRTSym : begin
Get;
ftype  :=  tdxefSqrt;
    end;
  LNSym : begin
Get;
ftype  :=  tdxefLn;
    end;
  FLOORSym : begin
Get;
ftype  :=  tdxefFloor;
    end;
  CEILSym : begin
Get;
ftype  :=  tdxefCeil;
    end;
  GCSSym : begin
Get;
ftype  :=  tdxefGCS;
    end;
  GCSRSym : begin
Get;
ftype  :=  tdxefGCSR;
    end;
  ARCSECSym : begin
Get;
ftype  :=  tdxefArcSec;
    end;
  ARCCSCSym : begin
Get;
ftype  :=  tdxefArcCsc;
    end;
  ARCCOTSym : begin
Get;
ftype  :=  tdxefArcCot;
    end;
  ARCSECHSym : begin
Get;
ftype  :=  tdxefArcSecH;
    end;
  ARCCSCHSym : begin
Get;
ftype  :=  tdxefArcCscH;
    end;
  ARCCOTHSym : begin
Get;
ftype  :=  tdxefArcCotH;
    end;
else begin SynError(137);
    end;
end;
end;

procedure TTDXExprParser._IfThenExpr (var  ExprResult:TTDXExpr);var  expr1,expr2,expr3:TTDXExpr;
begin
Expect(IFTHENSym);
Expect(_lparenSym);
_OrExpression(expr1);
Expect(_commaSym);
_OrExpression(expr2);
Expect(_commaSym);
_OrExpression(expr3);
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefIfThen,[PopNode(expr1),PopNode(expr2),PopNode(expr3)]));
end;

procedure TTDXExprParser._FunctionTrigExpr (var  ExprResult:TTDXExpr);var  exprRoot,expr:TTDXExpr;  ftype:TTDXExprFunctionType;
begin
exprRoot  :=  nil;  ftype  :=  tdxefSin;;
case fCurrentInputSymbol of
  SINSym : begin
Get;
ftype  :=  tdxefSin;;
    end;
  COSSym : begin
Get;
ftype  :=  tdxefCos;;
    end;
  TANSym : begin
Get;
ftype  :=  tdxefTan;;
    end;
  SECSym : begin
Get;
ftype  :=  tdxefSec;
    end;
  CSCSym : begin
Get;
ftype  :=  tdxefCsc;
    end;
  COTSym : begin
Get;
ftype  :=  tdxefCot;
    end;
  SINHSym : begin
Get;
ftype  :=  tdxefSinh;;
    end;
  COSHSym : begin
Get;
ftype  :=  tdxefCosh;;
    end;
  TANHSym : begin
Get;
ftype  :=  tdxefTanh;;
    end;
  SECHSym : begin
Get;
ftype  :=  tdxefSech;
    end;
  CSCHSym : begin
Get;
ftype  :=  tdxefCsch;
    end;
  COTHSym : begin
Get;
ftype  :=  tdxefCoth;
    end;
else begin SynError(138);
    end;
end;
if (fCurrentInputSymbol = _uparrowSym) OR
 (fCurrentInputSymbol = _atSUP_lbraceSym) then begin
if (fCurrentInputSymbol = _atSUP_lbraceSym) then begin
_SuperEq(exprRoot);
end else begin
Get;
_FactorUnary(exprRoot);
end;
end;
_FunctionParam(expr);

if  assigned(exprRoot)  then
begin
  expr  :=  popNode(expr);
  exprRoot  :=  popNode(exprRoot);
  if  exprRoot.isNumber  and  (exprRoot.ExprValue  =  -1)  then
  begin
    case  ftype  of
      tdxefSin  :  ftype  :=  tdxefArcSin;
      tdxefCos  :  ftype  :=  tdxefArcCos;
      tdxefTan  :  ftype  :=  tdxefArcTan;
      tdxefSec  :  ftype  :=  tdxefArcSec;
      tdxefCsc  :  ftype  :=  tdxefArcCsc;
      tdxefCot  :  ftype  :=  tdxefArcCot;
      tdxefSinh  :  ftype  :=  tdxefArcSinh;
      tdxefCosh  :  ftype  :=  tdxefArcCosh;
      tdxefTanh  :  ftype  :=  tdxefArcTanh;
      tdxefSech  :  ftype  :=  tdxefArcSech;
      tdxefCsch  :  ftype  :=  tdxefArcCsch;
      tdxefCoth  :  ftype  :=  tdxefArcCoth;
    end;
    ExprResult  :=  AddNode(TTDXExprFunction.Create(ftype,expr));
    (ExprResult  as  TTDXExprFunction).AltInverseForm  :=  true;
  end
  else
  begin
    ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebPower,TTDXExprFunction.Create(ftype,expr),exprRoot));
    (ExprResult  as  TTDXExprBinary).AltTrigPowerForm  :=  true;
  end;
end
else
begin
  ExprResult  :=  AddNode(TTDXExprFunction.Create(ftype,[PopNode(expr)]));
end;
;
end;

procedure TTDXExprParser._FunctionLogExpr (var  ExprResult:TTDXExpr);var  exprRoot,expr:TTDXExpr;
begin
exprRoot  :=  nil;;
Expect(LOGSym);
if (fCurrentInputSymbol = _atSUBSym) then begin
Get;
Expect(_lbraceSym);
if _In(symSet[2], fCurrentInputSymbol) then begin
_Literal(exprRoot);
end else if _In(symSet[3], fCurrentInputSymbol) then begin
_SymbolicVariable(exprRoot);
end else begin SynError(139);
end;
Expect(_rbraceSym);
end;
_FunctionParam(expr);

if  assigned(exprRoot)  then
begin
  expr  :=  popNode(expr);
  exprRoot  :=  popNode(exprRoot);
  ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefLogx,[exprRoot,expr]));
end
else
begin
  ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefLog,[PopNode(expr)]));
end;
;
end;

procedure TTDXExprParser._ModelExpr (var  ExprResult:  TTDXExpr);var  expr  :TTDXExpr;
begin
Expect(model_Sym);
ExprResult  :=  AddNode(TTDXExprModel.Create(LexString));;
Expect(_lparenSym);
_OrExpression(expr);
(ExprResult  as  TTDXExprModel).AddArg(PopNode(expr));;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_OrExpression(expr);
(ExprResult  as  TTDXExprModel).AddArg(PopNode(expr));;
end;
Expect(_rparenSym);
(ExprResult  as  TTDXExprModel).CheckSyntax;;
end;

procedure TTDXExprParser._MathExpr (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
begin
if (fCurrentInputSymbol = MATHSym) then begin
Get;
Expect(_lparenSym);
_OrExpression(expr);
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprMath.Create(PopNode(expr),false));;
end else if (fCurrentInputSymbol = MEVALSym) then begin
Get;
Expect(_lparenSym);
_OrExpression(expr);
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprMath.Create(PopNode(expr),true));;
end else begin SynError(140);
end;
end;

procedure TTDXExprParser._FunctionParam (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
     op:TTDXExprBinaryType;
     special:String;
begin
_Factor(ExprResult);
while _In(symSet[4], fCurrentInputSymbol) do begin
if _In(symSet[5], fCurrentInputSymbol) then begin
op  :=  tdxebMultiply;  special  :=  '';
_Factor(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(op,PopNode(ExprResult),PopNode(expr)));
     if  special  <>  ''  then
       TTDXExprBinary(ExprResult).OpName  :=  special;
;
end else if (fCurrentInputSymbol = _uparrowSym) then begin
Get;
_FactorUnary(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebPower,PopNode(ExprResult),PopNode(expr)));
               TTDXExprBinary(ExprResult).AltTrigPowerForm  :=  FForceAltTrigPowerForm;
end else begin
_SuperEq(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebPower,PopNode(ExprResult),PopNode(expr)));
               TTDXExprBinary(ExprResult).AltTrigPowerForm  :=  FForceAltTrigPowerForm;
end;
end;
end;

procedure TTDXExprParser._ObjectExpr (var  ExprResult:  TTDXExpr);var  expr  :TTDXExpr;
begin
Expect(object_Sym);
ExprResult  :=  AddNode(TTDXExprObject.Create(LexString));
(ExprResult  as  TTDXExprObject).OnObjectGetValue  :=  FOnObjectGetValue;
(ExprResult  as  TTDXExprObject).OnObjectCheckSyntax  :=  FOnObjectCheckSyntax;
;
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
_OrExpression(expr);
(ExprResult  as  TTDXExprObject).AddArg(PopNode(expr));;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_OrExpression(expr);
(ExprResult  as  TTDXExprObject).AddArg(PopNode(expr));;
end;
Expect(_rparenSym);
end;
(ExprResult  as  TTDXExprObject).CheckSyntax;;
end;

procedure TTDXExprParser._AbsEq (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
begin
Expect(_atABS_lbraceSym);
_OrExpression(Expr);
Expect(_rbraceSym);
ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefAbs,[PopNode(expr)]));
end;

procedure TTDXExprParser._NRootEq (var  ExprResult:TTDXExpr);var  expr1,expr2:TTDXExpr;
begin
expr1  :=  nil;
expr2  :=  nil;
;
Expect(_atRT_lbraceSym);
_OrExpression(Expr1);
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
_OrExpression(Expr2);
end;
Expect(_rbraceSym);
if  expr2  =  nil  then
   ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefSqrt,[PopNode(Expr1)]))
else
   ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefRTX,[PopNode(Expr2),PopNode(Expr1)]));
;
end;

procedure TTDXExprParser._DivideEq (var  ExprResult:TTDXExpr);var  expr1,expr2:TTDXExpr;
begin
Expect(_atDIV_lbraceSym);
_OrExpression(Expr1);
Expect(_semicolonSym);
_OrExpression(Expr2);
Expect(_rbraceSym);
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebDivide,PopNode(Expr1),PopNode(expr2)));
end;

procedure TTDXExprParser._SymbolicVariable (var  ExprResult:TTDXExpr);begin
case fCurrentInputSymbol of
  symbolicSym, entitySym : begin
if (fCurrentInputSymbol = symbolicSym) then begin
Get;
end else begin
Get;
end;
ExprResult  :=  AddNode(TTDXExprSymbolicVar.Create(LexString));
TTDXExprSymbolicVar(ExprResult).OnGetValue  :=  FOnSymVarGetValue;
if  assigned(FOnSymVarCreate)  then
   FOnSymVarCreate(ExprResult,LexString);
    end;
  PISym : begin
Get;
ExprResult  :=  AddNode(TTDXExprLiteral.CreateEq(pi,'&pi;'));
    end;
  _ESym : begin
Get;
ExprResult  :=  AddNode(TTDXExprLiteral.CreateEq(exp(1),'e'));
    end;
  _andPI_semicolonSym : begin
Get;
ExprResult  :=  AddNode(TTDXExprLiteral.CreateEq(pi,'&pi;'));
    end;
  _andEXP_semicolonSym : begin
Get;
ExprResult  :=  AddNode(TTDXExprLiteral.CreateEq(exp(1),'e'));
    end;
  _andINF_semicolonSym : begin
Get;
ExprResult  :=  AddNode(TTDXExprLiteral.CreateEq(Infinity,'&inf;'));
    end;
else begin SynError(141);
    end;
end;
end;

procedure TTDXExprParser._Literal (var  ExprResult:TTDXExpr);var  value:TTDXExprValue;
begin
if _In(symSet[6], fCurrentInputSymbol) then begin
_NumberLiteralVar(ExprResult);
end else if (fCurrentInputSymbol = string_Sym) then begin
_StringLiteral(value);
ExprResult  :=  AddNode(TTDXExprStringLiteral.Create(value,FIsMath));
end else if (fCurrentInputSymbol = TRUESym) OR
 (fCurrentInputSymbol = FALSESym) then begin
_BooleanLiteral(value);
ExprResult  :=  AddNode(TTDXExprLiteral.Create(value));
end else begin SynError(142);
end;
end;

procedure TTDXExprParser._FactorNoParen (var  ExprResult:  TTDXExpr);begin
case fCurrentInputSymbol of
  integer_Sym, floatSym, variableSym, string_Sym, _atMNUM_lbraceSym, NUMSym, _atCNUM_lbraceSym, 
      _atCURR_lbraceSym, _atNEGP_lbraceSym, TRUESym, FALSESym : begin
_Literal(ExprResult);
    end;
  symbolicSym, entitySym, PISym, _ESym, _andPI_semicolonSym, _andEXP_semicolonSym, _andINF_semicolonSym : begin
_SymbolicVariable(ExprResult);
    end;
  _atDIV_lbraceSym : begin
_DivideEq(ExprResult);
    end;
  _atRT_lbraceSym : begin
_NRootEq(ExprResult);
    end;
  _atABS_lbraceSym : begin
_AbsEq(ExprResult);
    end;
  object_Sym : begin
_ObjectExpr(ExprResult);
    end;
else begin SynError(143);
    end;
end;
end;

procedure TTDXExprParser._ParenExpression (var  ExprResult:TTDXExpr);var  Expr1  :  TTDXExpr;
begin
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
_OrExpression(ExprResult);
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_OrExpression(Expr1);
ExprResult  :=
AddNode(TTDXExprOrderedPair.Create(PopNode(ExprResult),PopNode(Expr1)));
end;
Expect(_rparenSym);
end else if (fCurrentInputSymbol = _andLBRACKET_semicolonSym) then begin
Get;
_OrExpression(ExprResult);
Expect(_andRBRACKET_semicolonSym);
end else if (fCurrentInputSymbol = _andLBRACE_semicolonSym) then begin
Get;
_OrExpression(ExprResult);
Expect(_andRBRACE_semicolonSym);
end else begin SynError(144);
end;
end;

procedure TTDXExprParser._Factor (var  ExprResult:TTDXExpr);begin
if (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _andLBRACKET_semicolonSym) OR
 (fCurrentInputSymbol = _andLBRACE_semicolonSym) then begin
_ParenExpression(ExprResult);
end else if _In(symSet[7], fCurrentInputSymbol) then begin
_FactorNoParen(ExprResult);
end else if (fCurrentInputSymbol = _barSym) then begin
_AbsExpression(ExprResult);
end else begin SynError(145);
end;
end;

procedure TTDXExprParser._FunctionExpr (var  ExprResult:TTDXExpr);var  expr,expr2:TTDXExpr;
   ftype:TTDXExprFunctionType;
begin
case fCurrentInputSymbol of
  MATHSym, MEVALSym : begin
_MathExpr(ExprResult);
    end;
  model_Sym : begin
_ModelExpr(ExprResult);
    end;
  LOGSym : begin
_FunctionLogExpr(ExprResult);
    end;
  SINSym, COSSym, TANSym, SECSym, CSCSym, COTSym, SINHSym, 
      COSHSym, TANHSym, SECHSym, CSCHSym, COTHSym : begin
_FunctionTrigExpr(ExprResult);
    end;
  IFTHENSym : begin
_IfThenExpr(ExprResult);
    end;
  ABSSym, ARCSINSym, ARCCOSSym, ARCTANSym, ARCSINHSym, ARCCOSHSym, ARCTANHSym, 
      EXPSym, SQRTSym, LNSym, FLOORSym, CEILSym, GCSSym, GCSRSym, ARCSECSym, 
      ARCCSCSym, ARCCOTSym, ARCSECHSym, ARCCSCHSym, ARCCOTHSym : begin
_Function1Arg(ftype);
_FunctionParam(expr);
ExprResult  :=  AddNode(TTDXExprFunction.Create(ftype,[PopNode(expr)]));
    end;
  DIVSym, DIVXSym, GCFSym, LCMSym, MIN_underscoreSym, MAX_underscoreSym, MODSym, 
      RTXSym, ROUNDSym, TRUNCSym, SIMPABSym, SIMPBASym, LOGXSym, PERMSym, COMBSym, 
      EQCASESym, NEQCASESym : begin
_Function2Arg(ftype);
Expect(_lparenSym);
_OrExpression(expr);
Expect(_commaSym);
_OrExpression(expr2);
Expect(_rparenSym);
ExprResult  :=  AddNode(TTDXExprFunction.Create(ftype,[PopNode(expr),PopNode(expr2)]));
    end;
  SYMEQSym : begin
_FunctionSimEQ(ExprResult);
    end;
  FILLARRAYSym, SUBARRAYSym, FRAC_twoMNUMSym : begin
_FunctionFinancial(ExprResult);
    end;
  MINSym, MAXSym : begin
_FunctionMultArg(ExprResult);
    end;
  REDUCESym : begin
_FunctionReduce(ExprResult);
    end;
else begin SynError(146);
    end;
end;
end;

procedure TTDXExprParser._SuperEq (var  ExprResult:TTDXExpr);begin
Expect(_atSUP_lbraceSym);
_OrExpression(ExprResult);
Expect(_rbraceSym);
end;

procedure TTDXExprParser._FactorFact (var  ExprResult:  TTDXExpr);begin
_Factor(ExprResult);
if (fCurrentInputSymbol = _bangSym) then begin
Get;
ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefFact,[PopNode(ExprResult)]));;
end;
end;

procedure TTDXExprParser._FactorPower (var  ExprResult:  TTDXExpr);var  expr:TTDXExpr;
begin
if _In(symSet[5], fCurrentInputSymbol) then begin
_FactorFact(ExprResult);
if (fCurrentInputSymbol = _uparrowSym) OR
 (fCurrentInputSymbol = _atSUP_lbraceSym) then begin
if (fCurrentInputSymbol = _uparrowSym) then begin
Get;
_FactorUnary(Expr);
end else begin
_SuperEq(Expr);
end;
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebPower,popNode(exprResult),popNode(expr)));
TTDXExprBinary(ExprResult).AltTrigPowerForm  :=  FForceAltTrigPowerForm;
end;
end else if _In(symSet[8], fCurrentInputSymbol) then begin
_FunctionExpr(ExprResult);
end else begin SynError(147);
end;
end;

procedure TTDXExprParser._MulOp (var  op:TTDXExprBinaryType;  var  special:String);begin
if (fCurrentInputSymbol = _starSym) then begin
special  :=  '';;
Get;
op  :=  tdxebMultiply;
end else if (fCurrentInputSymbol = _slashSym) then begin
Get;
op  :=  tdxebDivide;
end else if (fCurrentInputSymbol = _andTIMES_semicolonSym) then begin
Get;
op  :=  tdxebMultiply;  special  :=  LexString;;
end else if (fCurrentInputSymbol = _andDIV_semicolonSym) then begin
Get;
op  :=  tdxebDivide;   special  :=  LexString;;
end else begin SynError(148);
end;
end;

procedure TTDXExprParser._FactorUnary (var  ExprResult:TTDXExpr);var  minusFlag:boolean;
begin
minusFlag  :=  false;
while (fCurrentInputSymbol = _minusSym) do begin
Get;
minusFlag  :=  not  minusFlag;
end;
_FactorPower(ExprResult);
if  minusFlag  then
     ExprResult  :=  AddNode(TTDXExprUnary.Create(tdxeuMinus,popNode(exprResult)));
;
end;

procedure TTDXExprParser._Term (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
     op:TTDXExprBinaryType;
     special:String;
begin
_FactorUnary(ExprResult);
while _In(symSet[9], fCurrentInputSymbol) do begin
op  :=  tdxebMultiply;  special  :=  '';
if (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _slashSym) OR
 (fCurrentInputSymbol = _andTIMES_semicolonSym) OR
 (fCurrentInputSymbol = _andDIV_semicolonSym) then begin
_MulOp(op,special);
_FactorUnary(expr);
end else begin
_FactorPower(expr);
end;
ExprResult  :=  AddNode(TTDXExprBinary.Create(op,PopNode(ExprResult),PopNode(expr)));
                                                          if  special  <>  ''  then
                                                             TTDXExprBinary(ExprResult).OpName  :=  special;

;
end;
end;

procedure TTDXExprParser._AddOp (var  op:TTDXExprBinaryType);begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
op  :=  tdxebAdd;
end else if (fCurrentInputSymbol = _minusSym) then begin
Get;
op  :=  tdxebSubtract;
end else begin SynError(149);
end;
end;

procedure TTDXExprParser._TermFunc (var  ExprResult:TTDXExpr);begin
_Term(ExprResult);
end;

procedure TTDXExprParser._AbsExpression (var  ExprResult:TTDXExpr);begin
Expect(_barSym);
_SimpleExpression(ExprResult);
ExprResult  :=  AddNode(TTDXExprFunction.Create(tdxefAbs,[PopNode(ExprResult)]));;
Expect(_querySym);
end;

procedure TTDXExprParser._SimpleExpression (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
     op:TTDXExprBinaryType;
begin
_TermFunc(ExprResult);
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
_AddOp(op);
_TermFunc(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(op,PopNode(ExprResult),PopNode(expr)));
end;
end;

procedure TTDXExprParser._ListExpression (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
begin
Expect(_lbrackSym);
ExprResult  :=  AddNode(TTDXExprList.Create);;
_Expression(Expr);
TTDXExprList(ExprResult).AddExpr(PopNode(Expr));;
while (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _semicolonSym) do begin
if (fCurrentInputSymbol = _commaSym) then begin
Get;
end else begin
Get;
end;
_Expression(Expr);
TTDXExprList(ExprResult).AddExpr(PopNode(Expr));;
end;
Expect(_rbrackSym);
end;

procedure TTDXExprParser._RelOp (var  op:TTDXExprRelationalType);begin
case fCurrentInputSymbol of
  _equalSym : begin
Get;
op  :=  tdxerEQ;
    end;
  _lessSym : begin
Get;
op  :=  tdxerLT;
    end;
  _greaterSym : begin
Get;
op  :=  tdxerGT;
    end;
  _less_equalSym : begin
Get;
op  :=  tdxerLE;
    end;
  _greater_equalSym : begin
Get;
op  :=  tdxerGE;
    end;
  _less_greaterSym : begin
Get;
op  :=  tdxerNE;
    end;
  CONTAINSSym : begin
Get;
op  :=  tdxerContains;
    end;
  ONLYSym : begin
Get;
op  :=  tdxerOnly;
    end;
  _andLT_semicolonSym : begin
Get;
op  :=  tdxerLT;
    end;
  _andGT_semicolonSym : begin
Get;
op  :=  tdxerGT;
    end;
  _andLE_semicolonSym : begin
Get;
op  :=  tdxerLE;
    end;
  _andGE_semicolonSym : begin
Get;
op  :=  tdxerGE;
    end;
  _andNE_semicolonSym : begin
Get;
op  :=  tdxerNE;
    end;
else begin SynError(150);
    end;
end;
end;

procedure TTDXExprParser._Expression (var  ExprResult:TTDXExpr);begin
if (fCurrentInputSymbol = _lbrackSym) then begin
_ListExpression(ExprResult);
end else if _In(symSet[10], fCurrentInputSymbol) then begin
_SimpleExpression(ExprResult);
end else begin SynError(151);
end;
end;

procedure TTDXExprParser._BooleanExpression (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
     op:TTDXExprRelationalType;
begin
_Expression(ExprResult);
if _In(symSet[11], fCurrentInputSymbol) then begin
_RelOp(op);
_Expression(expr);
ExprResult  :=  AddNode(TTDXExprRelational.Create(op,PopNode(ExprResult),PopNode(expr)));
end;
end;

procedure TTDXExprParser._NotExpression (var  ExprResult:TTDXExpr);var  notCount:Integer;
begin
notCount  :=  0;;
while (fCurrentInputSymbol = NOTSym) do begin
Get;
inc(notCount);;
end;
_BooleanExpression(ExprResult);
while  notCount  >  0  do
begin
   ExprResult  :=  AddNode(TTDXExprUnary.Create(tdxeuNot,PopNode(exprResult)));
   dec(notCount);
end;
;
end;

procedure TTDXExprParser._AndExpression (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
begin
_NotExpression(ExprResult);
while (fCurrentInputSymbol = ANDSym) do begin
Get;
_NotExpression(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebAnd,PopNode(ExprResult),PopNode(expr)));
end;
end;

procedure TTDXExprParser._OrExpression (var  ExprResult:TTDXExpr);var  expr:TTDXExpr;
begin
_AndExpression(ExprResult);
while (fCurrentInputSymbol = ORSym) do begin
Get;
_AndExpression(expr);
ExprResult  :=  AddNode(TTDXExprBinary.Create(tdxebOr,PopNode(ExprResult),PopNode(expr)));
end;
end;

procedure TTDXExprParser._TDXExprParser;var  Expression  :  TTDXExpr;
begin
Init;
_OrExpression(Expression);
RootNode  :=  PopNode(Expression);;
if  fCurrentInputSymbol  <>  EOFSYMB  then
   SynError(200);
Final;
end;

function TTDXExprParser.GetBuildDate : TDateTime;
const
  BDate = 39353;
  Hour = 13;
  Min = 55;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TTDXExprParser.GetVersion : string;
begin
  Result := '0.0.0.400';
end;

function TTDXExprParser.GetVersionStr : string;
begin
  Result := '0.0.0.400';
end;

function TTDXExprParser.GetVersionInfo : string;
begin
  Result := 'Comment: ' + #13#10 +
'Author: ' + #13#10 +
'Copyright: ';
end;

procedure TTDXExprParser.SetVersion(const Value : string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TTDXExprParser.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_TDXExprParser;
end;  {Parse}

procedure TTDXExprParser.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 0, 4] := [];
symSet[ 0, 5] := [];
symSet[ 0, 6] := [];
symSet[ 0, 7] := [];
symSet[ 1, 0] := [integer_Sym, floatSym];
symSet[ 1, 1] := [];
symSet[ 1, 2] := [];
symSet[ 1, 3] := [];
symSet[ 1, 4] := [];
symSet[ 1, 5] := [];
symSet[ 1, 6] := [];
symSet[ 1, 7] := [NUMSym-112, _atCNUM_lbraceSym-112, _atCURR_lbraceSym-112, 
                    _atNEGP_lbraceSym-112];
symSet[ 2, 0] := [integer_Sym, floatSym, variableSym, string_Sym];
symSet[ 2, 1] := [];
symSet[ 2, 2] := [];
symSet[ 2, 3] := [];
symSet[ 2, 4] := [];
symSet[ 2, 5] := [];
symSet[ 2, 6] := [];
symSet[ 2, 7] := [_atMNUM_lbraceSym-112, NUMSym-112, _atCNUM_lbraceSym-112, 
                    _atCURR_lbraceSym-112, _atNEGP_lbraceSym-112, TRUESym-112, 
                    FALSESym-112];
symSet[ 3, 0] := [symbolicSym, entitySym];
symSet[ 3, 1] := [];
symSet[ 3, 2] := [];
symSet[ 3, 3] := [PISym-48, _ESym-48, _andPI_semicolonSym-48, 
                    _andEXP_semicolonSym-48, _andINF_semicolonSym-48];
symSet[ 3, 4] := [];
symSet[ 3, 5] := [];
symSet[ 3, 6] := [];
symSet[ 3, 7] := [];
symSet[ 4, 0] := [integer_Sym, floatSym, variableSym, symbolicSym, 
                    entitySym, object_Sym, string_Sym];
symSet[ 4, 1] := [_barSym-16];
symSet[ 4, 2] := [_uparrowSym-32, _atSUP_lbraceSym-32, _atRT_lbraceSym-32, 
                    _atABS_lbraceSym-32, _lparenSym-32, _atDIV_lbraceSym-32, 
                    _andLBRACKET_semicolonSym-32];
symSet[ 4, 3] := [_andLBRACE_semicolonSym-48, PISym-48, _ESym-48, 
                    _andPI_semicolonSym-48, _andEXP_semicolonSym-48, 
                    _andINF_semicolonSym-48];
symSet[ 4, 4] := [];
symSet[ 4, 5] := [];
symSet[ 4, 6] := [];
symSet[ 4, 7] := [_atMNUM_lbraceSym-112, NUMSym-112, _atCNUM_lbraceSym-112, 
                    _atCURR_lbraceSym-112, _atNEGP_lbraceSym-112, TRUESym-112, 
                    FALSESym-112];
symSet[ 5, 0] := [integer_Sym, floatSym, variableSym, symbolicSym, 
                    entitySym, object_Sym, string_Sym];
symSet[ 5, 1] := [_barSym-16];
symSet[ 5, 2] := [_atRT_lbraceSym-32, _atABS_lbraceSym-32, _lparenSym-32, 
                    _atDIV_lbraceSym-32, _andLBRACKET_semicolonSym-32];
symSet[ 5, 3] := [_andLBRACE_semicolonSym-48, PISym-48, _ESym-48, 
                    _andPI_semicolonSym-48, _andEXP_semicolonSym-48, 
                    _andINF_semicolonSym-48];
symSet[ 5, 4] := [];
symSet[ 5, 5] := [];
symSet[ 5, 6] := [];
symSet[ 5, 7] := [_atMNUM_lbraceSym-112, NUMSym-112, _atCNUM_lbraceSym-112, 
                    _atCURR_lbraceSym-112, _atNEGP_lbraceSym-112, TRUESym-112, 
                    FALSESym-112];
symSet[ 6, 0] := [integer_Sym, floatSym, variableSym];
symSet[ 6, 1] := [];
symSet[ 6, 2] := [];
symSet[ 6, 3] := [];
symSet[ 6, 4] := [];
symSet[ 6, 5] := [];
symSet[ 6, 6] := [];
symSet[ 6, 7] := [_atMNUM_lbraceSym-112, NUMSym-112, _atCNUM_lbraceSym-112, 
                    _atCURR_lbraceSym-112, _atNEGP_lbraceSym-112];
symSet[ 7, 0] := [integer_Sym, floatSym, variableSym, symbolicSym, 
                    entitySym, object_Sym, string_Sym];
symSet[ 7, 1] := [];
symSet[ 7, 2] := [_atRT_lbraceSym-32, _atABS_lbraceSym-32, 
                    _atDIV_lbraceSym-32];
symSet[ 7, 3] := [PISym-48, _ESym-48, _andPI_semicolonSym-48, 
                    _andEXP_semicolonSym-48, _andINF_semicolonSym-48];
symSet[ 7, 4] := [];
symSet[ 7, 5] := [];
symSet[ 7, 6] := [];
symSet[ 7, 7] := [_atMNUM_lbraceSym-112, NUMSym-112, _atCNUM_lbraceSym-112, 
                    _atCURR_lbraceSym-112, _atNEGP_lbraceSym-112, TRUESym-112, 
                    FALSESym-112];
symSet[ 8, 0] := [model_Sym];
symSet[ 8, 1] := [];
symSet[ 8, 2] := [];
symSet[ 8, 3] := [MATHSym-48, MEVALSym-48, MINSym-48, MAXSym-48, 
                    FILLARRAYSym-48, SUBARRAYSym-48, FRAC_twoMNUMSym-48, 
                    SYMEQSym-48];
symSet[ 8, 4] := [REDUCESym-64, SINSym-64, COSSym-64, TANSym-64, SECSym-64, 
                    CSCSym-64, COTSym-64, SINHSym-64, COSHSym-64, TANHSym-64, 
                    SECHSym-64, CSCHSym-64, COTHSym-64, IFTHENSym-64, LOGSym-64];
symSet[ 8, 5] := [ABSSym-80, ARCSINSym-80, ARCCOSSym-80, ARCTANSym-80, 
                    ARCSINHSym-80, ARCCOSHSym-80, ARCTANHSym-80, EXPSym-80, 
                    SQRTSym-80, LNSym-80, FLOORSym-80, CEILSym-80, GCSSym-80, 
                    GCSRSym-80, ARCSECSym-80];
symSet[ 8, 6] := [ARCCSCSym-96, ARCCOTSym-96, ARCSECHSym-96, ARCCSCHSym-96, 
                    ARCCOTHSym-96, DIVSym-96, DIVXSym-96, GCFSym-96, LCMSym-96, 
                    MIN_underscoreSym-96, MAX_underscoreSym-96, MODSym-96, 
                    RTXSym-96, ROUNDSym-96, TRUNCSym-96, SIMPABSym-96];
symSet[ 8, 7] := [SIMPBASym-112, LOGXSym-112, PERMSym-112, COMBSym-112, 
                    EQCASESym-112, NEQCASESym-112];
symSet[ 9, 0] := [integer_Sym, floatSym, variableSym, symbolicSym, 
                    entitySym, object_Sym, model_Sym, string_Sym];
symSet[ 9, 1] := [_barSym-16];
symSet[ 9, 2] := [_starSym-32, _slashSym-32, _andTIMES_semicolonSym-32, 
                    _andDIV_semicolonSym-32, _atRT_lbraceSym-32, 
                    _atABS_lbraceSym-32, _lparenSym-32, _atDIV_lbraceSym-32, 
                    _andLBRACKET_semicolonSym-32];
symSet[ 9, 3] := [_andLBRACE_semicolonSym-48, PISym-48, _ESym-48, 
                    _andPI_semicolonSym-48, _andEXP_semicolonSym-48, 
                    _andINF_semicolonSym-48, MATHSym-48, MEVALSym-48, MINSym-48, 
                    MAXSym-48, FILLARRAYSym-48, SUBARRAYSym-48, 
                    FRAC_twoMNUMSym-48, SYMEQSym-48];
symSet[ 9, 4] := [REDUCESym-64, SINSym-64, COSSym-64, TANSym-64, SECSym-64, 
                    CSCSym-64, COTSym-64, SINHSym-64, COSHSym-64, TANHSym-64, 
                    SECHSym-64, CSCHSym-64, COTHSym-64, IFTHENSym-64, LOGSym-64];
symSet[ 9, 5] := [ABSSym-80, ARCSINSym-80, ARCCOSSym-80, ARCTANSym-80, 
                    ARCSINHSym-80, ARCCOSHSym-80, ARCTANHSym-80, EXPSym-80, 
                    SQRTSym-80, LNSym-80, FLOORSym-80, CEILSym-80, GCSSym-80, 
                    GCSRSym-80, ARCSECSym-80];
symSet[ 9, 6] := [ARCCSCSym-96, ARCCOTSym-96, ARCSECHSym-96, ARCCSCHSym-96, 
                    ARCCOTHSym-96, DIVSym-96, DIVXSym-96, GCFSym-96, LCMSym-96, 
                    MIN_underscoreSym-96, MAX_underscoreSym-96, MODSym-96, 
                    RTXSym-96, ROUNDSym-96, TRUNCSym-96, SIMPABSym-96];
symSet[ 9, 7] := [SIMPBASym-112, LOGXSym-112, PERMSym-112, COMBSym-112, 
                    EQCASESym-112, NEQCASESym-112, _atMNUM_lbraceSym-112, 
                    NUMSym-112, _atCNUM_lbraceSym-112, _atCURR_lbraceSym-112, 
                    _atNEGP_lbraceSym-112, TRUESym-112, FALSESym-112];
symSet[10, 0] := [integer_Sym, floatSym, variableSym, symbolicSym, 
                    entitySym, object_Sym, model_Sym, string_Sym];
symSet[10, 1] := [_barSym-16];
symSet[10, 2] := [_minusSym-32, _atRT_lbraceSym-32, _atABS_lbraceSym-32, 
                    _lparenSym-32, _atDIV_lbraceSym-32, 
                    _andLBRACKET_semicolonSym-32];
symSet[10, 3] := [_andLBRACE_semicolonSym-48, PISym-48, _ESym-48, 
                    _andPI_semicolonSym-48, _andEXP_semicolonSym-48, 
                    _andINF_semicolonSym-48, MATHSym-48, MEVALSym-48, MINSym-48, 
                    MAXSym-48, FILLARRAYSym-48, SUBARRAYSym-48, 
                    FRAC_twoMNUMSym-48, SYMEQSym-48];
symSet[10, 4] := [REDUCESym-64, SINSym-64, COSSym-64, TANSym-64, SECSym-64, 
                    CSCSym-64, COTSym-64, SINHSym-64, COSHSym-64, TANHSym-64, 
                    SECHSym-64, CSCHSym-64, COTHSym-64, IFTHENSym-64, LOGSym-64];
symSet[10, 5] := [ABSSym-80, ARCSINSym-80, ARCCOSSym-80, ARCTANSym-80, 
                    ARCSINHSym-80, ARCCOSHSym-80, ARCTANHSym-80, EXPSym-80, 
                    SQRTSym-80, LNSym-80, FLOORSym-80, CEILSym-80, GCSSym-80, 
                    GCSRSym-80, ARCSECSym-80];
symSet[10, 6] := [ARCCSCSym-96, ARCCOTSym-96, ARCSECHSym-96, ARCCSCHSym-96, 
                    ARCCOTHSym-96, DIVSym-96, DIVXSym-96, GCFSym-96, LCMSym-96, 
                    MIN_underscoreSym-96, MAX_underscoreSym-96, MODSym-96, 
                    RTXSym-96, ROUNDSym-96, TRUNCSym-96, SIMPABSym-96];
symSet[10, 7] := [SIMPBASym-112, LOGXSym-112, PERMSym-112, COMBSym-112, 
                    EQCASESym-112, NEQCASESym-112, _atMNUM_lbraceSym-112, 
                    NUMSym-112, _atCNUM_lbraceSym-112, _atCURR_lbraceSym-112, 
                    _atNEGP_lbraceSym-112, TRUESym-112, FALSESym-112];
symSet[11, 0] := [_equalSym, _lessSym, _greaterSym];
symSet[11, 1] := [_less_equalSym-16, _greater_equalSym-16, 
                    _less_greaterSym-16, CONTAINSSym-16, ONLYSym-16, 
                    _andLT_semicolonSym-16, _andGT_semicolonSym-16, 
                    _andLE_semicolonSym-16, _andGE_semicolonSym-16, 
                    _andNE_semicolonSym-16];
symSet[11, 2] := [];
symSet[11, 3] := [];
symSet[11, 4] := [];
symSet[11, 5] := [];
symSet[11, 6] := [];
symSet[11, 7] := [];
end; {InitSymSet}

end { TDXExprParser }.    
